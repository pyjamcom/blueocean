{
  "tasks": [
    {
      "number": "1",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать отдельный Python‑скрипт генерации контента под новое позиционирование и сделать его пригодным для пакетной обработки страниц. Здесь нужно не просто сформировать текст, а построить воспроизводимый пайплайн: на входе — структурированный JSON с профилем позиционирования (ценностные оси, тональность, ограничения, обязательные дисклеймеры) и список URL/страниц; на выходе — строгий JSON‑маппинг полей (Meta Title, Hero, Content Notes, CTA/Modules, HTML‑фрагменты), готовый к дальнейшему применению. В рамках задачи требуется: определить модель входных данных, сделать валидацию обязательных полей (например: profile.name, tone, pages[].url), нормализовать ввод (трим, уникализация URL, дефолтные значения), собрать контентные шаблоны под ключевые оси позиционирования (подписка‑подарок, гурманский набор, ограниченность/ответственное потребление, социальная игра), и применить их детерминированно или с конфиг‑переменными. Результат должен быть детерминированным: одинаковый ввод → одинаковый вывод. Скрипт должен писать JSON с четкой схемой полей, чтобы следующий шаг мог безошибочно применить обновления. Важно описать в коде правила длины для title/hero/cta, предусмотреть fallback‑текст, а также поддержку нескольких языков (минимум ключ для языка, даже если пока используется один). Выходной JSON должен содержать для каждой страницы ссылку на оригинальный URL, версии контента, и метаданные генерации (дата, версия шаблона). Эта задача — основа всего контентного обновления: без строгой схемы и шаблонов нельзя автоматизировать дальнейшие шаги.",
      "subtasks": [
        {
          "number": "1.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Определить формат входного JSON и реализовать его валидацию. Нужно явно описать, какие поля обязательны и как они должны выглядеть: например, profile (объект), tone (строка), pages (массив объектов), pages[].url (строка), pages[].intent (строка), key_points (массив). Дополнительно стоит предусмотреть опциональные поля для расширения: locale, restrictions, brand_terms, banned_phrases, mandatory_disclaimer. Валидация должна проверять: типы данных, пустые значения, дубликаты URL, наличие ключевых полей, корректность структуры массива страниц. Ошибки валидации должны быть читаемыми и указывать путь к полю (например: pages[3].url). Если данные некорректны, скрипт должен завершаться с понятным сообщением и кодом ошибки. Также нужно нормализовать значения: убрать пробелы, привести URL к каноническому виду, задать дефолты. Это обеспечит стабильность дальнейшей генерации и исключит разъезды между входом и выходом.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "1.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать библиотеку шаблонов копирайта под три ключевые смысловые оси. Необходимо сформировать минимум по 3–5 шаблонов на каждую ось: subscription‑gift (подписка как подарок), gourmet‑tasting (вкусовой набор и дегустация), small‑quantity/positive‑social (ограниченность, ответственное потребление, игра с друзьями). Каждый шаблон должен иметь структуру: заголовок/подзаголовок/описание/CTA, и поддерживать параметризацию (например: сезон, регион, число бутылок, тональность). Шаблоны должны учитывать ограничения по длине для мета‑полей и CTA. Также важно предусмотреть правила комбинирования осей: например, основной акцент на подарке, но вторичная вставка про дегустацию. В коде нужно реализовать механизм выбора шаблона (по intent страницы или по набору ключевых точек) и генерации итогового текста. Результат должен быть логичным и не повторяться между страницами при одинаковых входных данных.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "1.3",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сформировать выходной JSON‑маппинг по каждому URL. Задача — превратить шаблонный текст в чёткую структуру данных, пригодную для применения к CSV: поля Meta Title, Hero / Content Notes, CTA / Modules, HTML‑фрагмент. Нужно обеспечить единый формат ключей: например meta_title, hero_title, hero_subtitle, content_notes, cta_primary, modules_html. Для каждой страницы должны быть указаны исходный URL, дата генерации, версия шаблона, а также маркер языка/локали. Дополнительно стоит включить поле warnings, если текст не помещается в ограничения по длине. Выходной JSON должен быть валидируемым, чтобы следующий скрипт мог применить значения без ручной проверки. Обязательно протестировать на 2–3 фиктивных страницах, чтобы убедиться в корректности структуры.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        }
      ]
    },
    {
      "number": "2",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать Python‑скрипт, который применяет JSON‑маппинг к исходному CSV. Цель — автоматизировать обновление контента в структурном файле без ручной правки. Скрипт должен читать CSV с сохранением порядка колонок и кодировкой, находить строки по URL, обновлять конкретные поля и записывать новый CSV. Важно реализовать защиту: если URL из JSON не найден в CSV — фиксировать это в отчёте; если поля отсутствуют — выводить ошибку. Скрипт должен поддерживать dry‑run (только отчёт без записи) и выводить summary: сколько строк обновлено, сколько пропущено, какие поля изменены. Нужно обеспечить, чтобы обновления не ломали формат CSV и не меняли другие колонки. Этот шаг критичен, потому что именно здесь контент реально попадает в рабочий файл.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "2.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать корректное чтение CSV с сохранением структуры. Нужно определить разделитель (запятая/точка с запятой), обработать BOM, корректно поддерживать UTF‑8 и UTF‑8‑SIG. Скрипт должен загружать CSV в память с сохранением порядка колонок и оригинальных имён. Важно не потерять пустые значения и не изменить порядок строк. Также стоит предусмотреть аргумент командной строки для указания явного разделителя, если автоопределение ошибается.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "2.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать логику поиска строк по URL и обновления полей. Нужно сравнивать URL из JSON‑маппинга со столбцом URL в CSV, при необходимости нормализовать (убрать слэш, привести к нижнему регистру). После нахождения строки — обновить только целевые колонки (Meta Title, Hero / Content Notes, CTA / Modules, HTML). Если JSON содержит поле, которого нет в CSV — вывести предупреждение. Также нужно поддержать режим частичного обновления (например, только meta_title и hero).\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "2.3",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сохранить CSV и сформировать итоговый отчёт. Скрипт должен писать новый CSV (либо поверх исходного, либо в новый путь), сохраняя кодировку и разделитель. После записи вывести summary: сколько URL обновлено, сколько не найдено, какие поля изменялись. Отчёт должен быть также доступен в JSON‑виде, чтобы его можно было использовать в последующих шагах (например, для HTML‑отчёта).\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        }
      ]
    },
    {
      "number": "3",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать Python‑скрипт генерации Google Ads RSA ассетов под новое позиционирование. Нужно сформировать набор заголовков и описаний, которые соответствуют требованиям RSA: headlines до 30 символов, descriptions до 90. Шаблоны должны отражать ключевые оси ценности (подарок, дегустация, ответственность) и быть разнообразными по формулировке. Скрипт должен уметь удалять дубликаты, проверять длины, выдавать финальный список в CSV/JSON формате, пригодном для импорта в Google Ads. Также полезно включить параметризацию по языку и региону. Это позволит запускать кампании без ручной генерации ассетов.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "3.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Задать библиотеку шаблонов заголовков и описаний. Нужно минимум 15–20 headline‑вариантов и 6–10 descriptions, разделённых по смысловым группам (gift, tasting, small‑quantity, social game). Каждый шаблон должен быть записан так, чтобы укладываться в ограничения по длине даже после подстановки переменных. Рекомендуется создать словарь переменных (например: season, city) и правила их замены. Шаблоны должны быть реалистичными для рекламы, без запрещённых обещаний.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "3.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать валидатор длины и уникальности. Скрипт должен считать длину строк, отбрасывать варианты, превышающие лимиты, и фиксировать это в отчёте. Также необходимо удалять дубликаты (case‑insensitive), чтобы не было повторов в RSA. Результатом должна быть чистая, валидная коллекция ассетов.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "3.3",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Экспортировать ассеты в CSV/JSON, пригодные для импорта. CSV должен содержать тип ассета, текст, опционально label. JSON — массив объектов. Нужно добавить метаданные: версия шаблона, дата генерации. Это позволит в любой момент пересобрать ассеты и сравнить версии.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        }
      ]
    },
    {
      "number": "4",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать Python‑скрипт генерации FAQ и ответов на возражения. FAQ должен отражать главные сомнения пользователей о подписке, подарке, доставке и безопасном употреблении. Скрипт должен брать входные параметры (страна, сезон, набор) и собирать готовые HTML‑фрагменты FAQ для каждой страницы. Важно формировать не только Q/A, но и корректную разметку, чтобы вставка в страницу была простой и стандартизированной.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "4.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Создать набор шаблонов вопросов и ответов. Нужно минимум 8–12 Q/A, с параметрами (сезон, страна, количество бутылок, формат подарка). В шаблонах должны быть предусмотрены дисклеймеры 21+ и корректная формулировка без мед. обещаний.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "4.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Экспортировать HTML‑фрагменты FAQ в JSON‑маппинг по URL. Для каждой страницы должен быть блок FAQ с готовой разметкой. Формат должен быть совместим с дальнейшим применением в CSV/контент‑платформе.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        }
      ]
    },
    {
      "number": "5",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать скрипт комплаенс‑проверки контента. Он должен автоматически искать обязательные дисклеймеры 21+, выявлять рискованные формулировки (например, обещания здоровья/лечения), и формировать отчёт по каждой странице. Цель — снизить юридические риски и обеспечить соответствие правилам алкогольной рекламы.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "5.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать набор регэксп‑правил для поиска дисклеймеров и рискованных фраз. Правила должны быть расширяемыми, список хранится в конфиге. Должно быть разделение на ошибки и предупреждения.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "5.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сформировать отчёт по URL: missing_age_gate, risky_health_claims, promote_overconsumption и др. Отчёт должен быть в JSON и пригоден для включения в общий HTML‑репорт.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        }
      ]
    },
    {
      "number": "6",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать CLI‑скрипт архивирования CSV. Перед любым обновлением файл должен копироваться в архивную папку с таймстампом. Это позволяет откатить изменения и иметь историю обновлений.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "6.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать CLI‑аргументы: --input, --archive-dir, --prefix. Скрипт должен работать как с абсолютными путями, так и с относительными.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "6.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сформировать имя архива с ISO‑таймстампом и безопасными символами. Важно исключить пробелы, двоеточия и другие проблемные символы для файловых систем.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        }
      ]
    },
    {
      "number": "7",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать Python‑скрипт валидации структуры CSV. Цель — убедиться, что обязательные колонки присутствуют, нет дублей URL, а структура соответствует ожиданиям генераторов контента.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "7.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Автоопределение разделителя CSV и корректная обработка кодировок. Скрипт должен уметь корректно читать файлы с BOM и без него.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "7.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Проверить обязательные колонки: Published, Page, URL, Intent, Target Keywords, Meta Title и др. Если чего‑то нет — формировать ошибку.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "7.3",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сформировать JSON‑отчёт по ошибкам и предупреждениям. Отчёт должен быть пригоден для включения в итоговый HTML‑репорт.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        }
      ]
    },
    {
      "number": "8",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать генератор HTML‑отчёта по итогам обновлений. Отчёт должен включать список обновлённых URL, изменения по полям, предупреждения комплаенса и метрики. Это нужно для визуальной проверки качества автоматизации.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "8.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сделать HTML‑шаблон с секциями: Copy Updates, FAQ Updates, Ad Assets, Compliance, Summary. Шаблон должен быть читаемым и пригодным для передачи стейкхолдерам.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        },
        {
          "number": "8.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать CLI‑параметры: --data-json, --out-html, --title, --date. Скрипт должен уметь собирать отчёт из разных JSON‑файлов.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. "
        }
      ]
    },
    {
      "number": "9",
      "status": "pending",
      "notes": "Standalone client feature; no dependency on other tasks. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Implement a self‑contained Starter Quest flow in the client. Нужно реализовать локальный (offline/mock) контур: каталог квестов, выбор подходящего квеста, запуск таймера, и завершение с отображением результата. Это ядро Джеспер‑механики: пользователь сразу получает задание без ожидания зрителей. Минимальная реализация должна работать в dev‑режиме без бэка, чтобы тестировать UX.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "9.1",
          "status": "pending",
          "notes": "Data-only task; safe to do first or last. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Add local quest catalog file with at least 20 safe quests. Каталог должен содержать id, текст задания, safe_tags, длительность и возрастные ограничения. Этот файл — источник всех auto‑quests для старта.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "9.2",
          "status": "pending",
          "notes": "Type definitions only. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Create quest type definitions. Нужно типизировать Quest, QuestCategory, QuestSafety и т.д., чтобы остальные части кода могли безопасно работать с заданиями.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "9.3",
          "status": "pending",
          "notes": "Pure logic function; unit-testable. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Add a quest selection function that filters by safe_tags and locale. Алгоритм должен учитывать возраст, локацию, избегать повторов и выбирать безопасные задания.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "9.4",
          "status": "pending",
          "notes": "No backend dependency; local state only. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Implement useStarterQuest hook/state machine. Логика: start → countdown → complete → emit event. Должны быть переходы на cancel/timeout, а также защита от двойного старта.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "9.5",
          "status": "pending",
          "notes": "UI overlay only. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Add in‑stream overlay component. Он показывает текст задания, таймер, кнопку Done, и краткий статус. UI должен быть минимальным и не перекрывать основной стрим.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "10",
      "status": "pending",
      "notes": "Standalone UI feature; can be implemented without server changes. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Add Glow Pin map overlay with TTL. Нужно визуально подсветить активные стартовые стримы на карте и автоматически убирать подсветку по истечении времени. Это основа социального заражения: другие видят “светящийся пин” и включаются.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "10.1",
          "status": "pending",
          "notes": "Data model only. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Define GlowPin model with id, lat/lng, started_at, ttl_sec, style. Модель нужна для рендера и контроля времени жизни.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "10.2",
          "status": "pending",
          "notes": "UI-only task. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Create GlowPin layer/component with pulse animation. Нужно обеспечить заметную, но не агрессивную подсветку на карте.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "10.3",
          "status": "pending",
          "notes": "Simple timer cleanup. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Add TTL expiry logic to remove pins. Это может быть таймер или периодическая проверка времени.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "10.4",
          "status": "pending",
          "notes": "Local demo only. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Add dev‑only toggle/mock data. Должна быть возможность включить тестовые пины без реальных стримов для проверки UI.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "11",
      "status": "pending",
      "notes": "Standalone UI feature; no backend dependency required. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Implement an instant reward UI: a toast plus a shareable card generated on the client after quest completion.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "11.1",
          "status": "pending",
          "notes": "UI-only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Create a RewardToast component that shows reward name, amount (optional), and a short confirmation.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "11.2",
          "status": "pending",
          "notes": "Pure client utility. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a share-card generator (canvas/SVG) that renders quest title, Glow Pin badge, and timestamp.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "11.3",
          "status": "pending",
          "notes": "No external integrations required. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a client-only share flow that saves the card as an image file or opens a native share sheet when available.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "12",
      "status": "pending",
      "notes": "Standalone shared module; safe to implement independently. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Create a local After-School Rush scheduler that determines whether the current time is within a configured daily window.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "12.1",
          "status": "pending",
          "notes": "Config only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a schedule config file (e.g., config/rush_schedule.json) with per-locale start/end times and timezone.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "12.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a function (e.g., isRushActive(now, locale)) that returns true/false and minutes remaining.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "12.3",
          "status": "pending",
          "notes": "Self-contained tests. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add unit tests covering boundary times, daylight saving edge cases, and incorrect locale values.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "13",
      "status": "pending",
      "notes": "Standalone persistence module; implement with local storage or a small DB table. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Implement streak tracking for creators: update streak on quest completion, compute current streak, and expose streak status for UI.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "13.1",
          "status": "pending",
          "notes": "Data model only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a Streak record model with fields: user_id, current_streak, last_completed_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "13.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement updateStreak(user_id, completed_at) with correct day-boundary handling.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "13.3",
          "status": "pending",
          "notes": "Optional feature; keep independent. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add an optional streak-freeze flag that preserves streak for a single missed day.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "13.4",
          "status": "pending",
          "notes": "Thin API layer. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Expose a getStreakStatus(user_id) helper that returns current streak and next deadline.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "14",
      "status": "pending",
      "notes": "Standalone aggregation module; no dependency on other features. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Implement a daily school leaderboard aggregator that ranks schools by completed quests within a time window.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "14.1",
          "status": "pending",
          "notes": "Schema only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Define a QuestCompletionEvent with fields: event_id, user_id, school_id, completed_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "14.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a daily aggregation function that counts completions per school for a given date.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "14.3",
          "status": "pending",
          "notes": "Simple API. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a read-only endpoint or function that returns Top-N schools with counts and rank.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "15",
      "status": "pending",
      "notes": "Standalone backend guard; does not require UI changes. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Add an anti-fraud validator for quest completion that enforces minimum stream duration and basic rate limits.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "15.1",
          "status": "pending",
          "notes": "Pure validation logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement min-duration validation (e.g., >= 45 seconds) before accepting quest completion.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "15.2",
          "status": "pending",
          "notes": "Local-only rate limit. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add per-device or per-user daily cap for starter rewards (e.g., 1/day).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "15.3",
          "status": "pending",
          "notes": "Heuristic rule; no ML. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a duplicate-content heuristic that flags repeated completions with identical duration and metadata.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "15.4",
          "status": "pending",
          "notes": "Audit trail only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Persist fraud flags to an audit log for later review.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "16",
      "status": "pending",
      "notes": "Standalone analytics module; can be added without other features. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Add client and server event logging for quest start, quest completion, glow awarded, and streak updated.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "16.1",
          "status": "pending",
          "notes": "Constants only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Define event names and payload schemas in a shared constants file.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "16.2",
          "status": "pending",
          "notes": "Client-only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a client event emitter with batching and a retry queue.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "16.3",
          "status": "pending",
          "notes": "Server-only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a simple server endpoint to accept events and write them to storage.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "17",
      "status": "pending",
      "notes": "Standalone config + pure calculation; no dependencies. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Add a reward budget configuration and calculator module that uses a fixed conversion rate (1 PJM = $0.01) to compute daily and monthly USD spend caps per school.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "17.1",
          "status": "pending",
          "notes": "Config only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Create a reward budget config file (e.g., config/reward_budget.json) with fields: pjm_usd_rate, daily_cap_per_school_pjm, per_user_daily_cap_pjm, and category_allocations (starter, streak, referral, rush).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "17.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a calculator function that returns daily and monthly USD caps per school and total network cap for N schools.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "17.3",
          "status": "pending",
          "notes": "Self-contained tests. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add unit tests for conversion accuracy and rounding rules using 1 PJM = $0.01.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "18",
      "status": "pending",
      "notes": "Standalone allocation engine; pure functions. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Implement a reward allocation engine that computes PJM payouts per event type (starter quest, streak milestones, referral quality, rush pool).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "18.1",
          "status": "pending",
          "notes": "Constants only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Define reward event types and default payout values (starter_quest, streak_d1, streak_d3, streak_d7, referral_new_user, referral_retained, rush_ranked).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "18.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement allocation for Starter Quest with a fixed payout (default 10 PJM) and a one-per-day constraint enforced by caller context.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "18.3",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement allocation for streak milestones (D1=15 PJM, D3=25 PJM, D7=100 PJM) with milestone detection handled by caller context.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "18.4",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement referral allocation with two-stage payouts (new_user_completion and retained_day2) returning separate rewards.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "18.5",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement rush pool distribution for Top-N ranks using a configurable payout table and a fixed pool size.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "19",
      "status": "pending",
      "notes": "Standalone budget guard; can wrap any allocator. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Add budget guard logic that enforces per-school daily caps, per-user daily caps, and soft throttling when spend reaches 80% of the daily cap.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "19.1",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement per-school daily cap enforcement that rejects or reduces rewards once the cap is reached.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "19.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement per-user daily cap enforcement that blocks rewards after the user reaches the daily max.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "19.3",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement soft throttling: when school spend exceeds 80% of the daily cap, reduce rewards by a configurable factor.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "19.4",
          "status": "pending",
          "notes": "Self-contained tests. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add unit tests covering cap enforcement and throttling behavior at 80% and 100% thresholds.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "20",
      "status": "pending",
      "notes": "Standalone accounting module; no runtime dependency on other tasks. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Implement a reward payout ledger and daily rollups to track PJM spend per school and per user.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "20.1",
          "status": "pending",
          "notes": "Schema only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Define RewardPayoutEvent with fields: event_id, user_id, school_id, reward_type, pjm_amount, created_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "20.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement daily rollup functions to compute total PJM spent per school and per user for a given date.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "20.3",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a runway calculator that estimates remaining days given a treasury size and configured daily caps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "21",
      "status": "pending",
      "notes": "Standalone reporting module; can read from rollups only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Create a daily budget report generator that outputs per-school spend (PJM and USD) and remaining budget for the day.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "21.1",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement a report builder that joins rollups with budget config to compute spent_pjm, spent_usd, remaining_pjm, and remaining_usd.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "21.2",
          "status": "pending",
          "notes": "Output-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a serializer that writes the report as JSON (e.g., reports/budget_daily_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "22",
      "status": "pending",
      "notes": "Standalone geo module to drive local network effects. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement geo-cell indexing and local feed ranking to surface nearby streams with a micro-local bias.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "22.1",
          "status": "pending",
          "notes": "Data model only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Define a GeoCell model (cell_id, lat, lng, radius_m) and attach it to stream metadata.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "22.2",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement a cell-mapping function that buckets a stream into the nearest GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "22.3",
          "status": "pending",
          "notes": "Query-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a local feed query that returns streams ordered by proximity and recency within a GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "22.4",
          "status": "pending",
          "notes": "Unit-testable. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add tests for cell mapping and proximity ranking with edge-case coordinates.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "23",
      "status": "pending",
      "notes": "Standalone growth feature; no dependency on other tasks. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement local invite tokens (QR/deep link) that attribute new users to a GeoCell or school group.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "23.1",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Create an invite token generator that encodes inviter_id, geo_cell_id, and expiration.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "23.2",
          "status": "pending",
          "notes": "Server-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a token validation endpoint that returns attribution metadata for signup/join flows.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "23.3",
          "status": "pending",
          "notes": "Local storage only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Persist invite attribution on device and attach it to the first quest completion event.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "23.4",
          "status": "pending",
          "notes": "Anti-abuse guard. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add rate limits on invite generation and validation per user/day.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "24",
      "status": "pending",
      "notes": "Standalone interaction module; can be implemented without rewards. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement a lightweight real-time challenge system where viewers issue micro-quests and streamers accept/complete them.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "24.1",
          "status": "pending",
          "notes": "Schema only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Define a Challenge model with fields: id, stream_id, issuer_id, text, status, created_at, expires_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "24.2",
          "status": "pending",
          "notes": "Server-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add endpoints to create, accept, and complete challenges with basic authorization.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "24.3",
          "status": "pending",
          "notes": "Client-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a challenge queue UI for streamers to accept/complete a challenge within a time window.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "24.4",
          "status": "pending",
          "notes": "Anti-abuse. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add per-viewer rate limits and a profanity/safety filter for challenge text.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "25",
      "status": "pending",
      "notes": "Standalone economy module; can be used with or without crypto transfer. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement an internal reward wallet with locked/unlocked balances and delayed unlock rules.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "25.1",
          "status": "pending",
          "notes": "Schema only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Define WalletBalance with fields: user_id, available_pjm, locked_pjm, updated_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "25.2",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement applyReward(user_id, pjm_amount, locked_ratio) that splits rewards into available and locked amounts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "25.3",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement unlockRules that release locked PJM after N quest completions or N active days.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "25.4",
          "status": "pending",
          "notes": "Simple API. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a balance endpoint or helper that returns available and locked PJM for the client UI.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "26",
      "status": "pending",
      "notes": "Standalone safety module; deterministic rules only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement a safety rules engine that flags streams and challenges based on configurable policy rules.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "26.1",
          "status": "pending",
          "notes": "Config only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Create a safety rules config file with denylisted words, max message length, and quiet-hours rules.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "26.2",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement a rules evaluator that returns flags and enforcement actions (warn, hide, throttle).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "26.3",
          "status": "pending",
          "notes": "Server-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add an enforcement hook that applies actions to streams/challenges based on rule flags.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "26.4",
          "status": "pending",
          "notes": "Audit trail only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Persist rule hits and enforcement actions in a safety audit log.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "27",
      "status": "pending",
      "notes": "Standalone analytics; reads from events only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Add geo-scale health metrics: supply/demand ratio per GeoCell and creator retention by cell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "27.1",
          "status": "pending",
          "notes": "Schema only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Define a GeoCellDailyMetrics record with fields: cell_id, date, streams_started, viewers, quests_completed.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "27.2",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement daily aggregation for supply/demand ratio (streams_started vs viewers) per GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "27.3",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Compute creator retention by GeoCell (D1/D7) using quest completion events.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "27.4",
          "status": "pending",
          "notes": "Output-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a JSON report generator for geo-scale metrics (e.g., reports/geo_metrics_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "28",
      "status": "completed",
      "notes": "Standalone product strategy tooling; config + visualization. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement a Strategy Canvas tool that renders value curves for Pyjam vs competitors from a local config file.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "28.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Create a strategy_canvas.json file with factors (geo, interactivity, monetization, safety, entry_barrier, content_realness) and per-product scores.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "28.2",
          "status": "completed",
          "notes": "UI-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Build a small chart renderer (SVG/Canvas) that visualizes value curves from the config.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "28.3",
          "status": "completed",
          "notes": "Output-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add an export-to-JSON snapshot for tracked changes in value curves over time.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "29",
      "status": "pending",
      "notes": "Standalone config + validation; no runtime dependency. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement an ERRC (Eliminate-Reduce-Raise-Create) grid config and a linter that checks new feature flags against the grid.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "29.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Create errc_grid.json with arrays for eliminate, reduce, raise, create factors.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "29.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a linter script that reads feature flags and ensures each new flag maps to a grid factor.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "29.3",
          "status": "pending",
          "notes": "CI-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Wire the linter into CI to fail when a feature change is not aligned to the grid.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "30",
      "status": "pending",
      "notes": "Standalone onboarding module; no dependency on rewards. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement a zero-friction 'Go Live in 1 Tap' entry that bypasses setup and starts a 60-second stream instantly.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "30.1",
          "status": "pending",
          "notes": "UI-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a QuickStart button on the map screen that launches the stream immediately with defaults.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "30.2",
          "status": "pending",
          "notes": "Client-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement default stream settings (no title, no category) and auto-start the camera.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "30.3",
          "status": "pending",
          "notes": "Analytics-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Track conversion from map view to first live stream for QuickStart vs standard flow.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "31",
      "status": "pending",
      "notes": "Standalone loop orchestrator; can run with mocks. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a Klaus-loop orchestrator that guarantees the first quest, instant reward UI, and Glow Pin for first-time streamers.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "31.1",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add an orchestrator that triggers: quest_assigned -> quest_completed -> reward_granted -> glow_applied.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "31.2",
          "status": "pending",
          "notes": "Client-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Integrate the orchestrator with the stream UI using a local mock reward source.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "31.3",
          "status": "pending",
          "notes": "Analytics-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Emit a single composite event that captures the full loop completion for funnel analysis.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "32",
      "status": "pending",
      "notes": "Standalone noncustomer conversion module. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a viewer-to-creator conversion flow that prompts passive viewers to try a 60-second stream with a safe quest.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "32.1",
          "status": "pending",
          "notes": "UI-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add a modal or inline prompt that appears after a viewer watches N seconds of a nearby stream.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "32.2",
          "status": "pending",
          "notes": "Client-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Preload a safe quest and show a one-tap action to start streaming immediately.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "32.3",
          "status": "pending",
          "notes": "Analytics-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Track conversion from viewer to creator for the prompt flow.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "33",
      "status": "pending",
      "notes": "Standalone reward tapering; pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a reward tapering engine that gradually shifts incentives from PJM to visibility/status as a creator becomes active.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "33.1",
          "status": "pending",
          "notes": "Config only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Create reward_tapering.json with tiers (new, warm, habitual) and payout multipliers per tier.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "33.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Implement a tier resolver that assigns a creator to a tier based on completed quests and active days.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "33.3",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Apply tapering to PJM payouts and substitute with Glow/Boost flags when payout is reduced.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "34",
      "status": "pending",
      "notes": "Standalone local fame layer; UI + aggregation. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a local fame leaderboard and map overlays that highlight top creators per school/GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "34.1",
          "status": "pending",
          "notes": "Schema only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Define LocalFameScore with fields: user_id, cell_id, score, date, rank.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "34.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Implement daily scoring rules for local fame (quests completed, streak milestones, viewer interactions).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "34.3",
          "status": "pending",
          "notes": "UI-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add a map overlay for Top-3 local creators with visible badges and pin styles.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "34.4",
          "status": "pending",
          "notes": "Output-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add a JSON leaderboard endpoint or report for local fame rankings.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "35",
      "status": "pending",
      "notes": "Standalone safety template module; no AI dependency. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a safe challenge template library for avatar tasks with allowlist tags and automatic rejection of unsafe prompts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "35.1",
          "status": "pending",
          "notes": "Config only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Create safe_challenge_templates.json with template ids, text, safe_tags, and age_rating.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "35.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Implement a validator that rejects challenges not matching allowlisted tags or exceeding max length.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "35.3",
          "status": "pending",
          "notes": "Server-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add an endpoint to serve safe templates and fallback to templates when user input is blocked.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "36",
      "status": "pending",
      "notes": "Standalone ritual scheduler; config-driven. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a daily ritual calendar that assigns a themed local challenge window per GeoCell (e.g., after-school theme).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "36.1",
          "status": "pending",
          "notes": "Config only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Create ritual_calendar.json with per-day themes, start/end times, and eligible GeoCells.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "36.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Implement a scheduler that returns the active ritual theme for a given GeoCell and time.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "36.3",
          "status": "pending",
          "notes": "UI-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Expose the active ritual theme as a map banner and filter for relevant quests.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "37",
      "status": "pending",
      "notes": "Standalone strategy guard; CI-integrated. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a Strategic Sequence checker (utility → price → cost → adoption) as a config + linter for new features.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "37.1",
          "status": "completed",
          "notes": "Config only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Create strategic_sequence.json defining required checks and thresholds per feature type.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "37.2",
          "status": "completed",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add a linter that validates each feature flag entry includes utility, price impact, cost impact, and adoption risk tags.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "37.3",
          "status": "pending",
          "notes": "CI-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Wire the sequence checker into CI to block changes missing strategic sequence metadata.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "38",
      "status": "pending",
      "notes": "Standalone noncustomer analytics. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement noncustomer tier tagging (soon-to-be, refusing, unexplored) and track conversion into creators.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "38.1",
          "status": "pending",
          "notes": "Schema only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Define NoncustomerTag with fields: user_id, tier, tagged_at, reason_code.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "38.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add tagging rules based on engagement signals (views only, no quests, no streams).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "38.3",
          "status": "pending",
          "notes": "Analytics-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Track conversion from each tier into first stream and first quest completion.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "39",
      "status": "pending",
      "notes": "Standalone trust loop safeguards; deterministic rules. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement anti-bullying throttles for repeated negative interactions within a GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "39.1",
          "status": "pending",
          "notes": "Schema only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Define InteractionFlag with fields: user_id, target_id, flag_type, count, last_seen_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "39.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add throttling rules that reduce interaction privileges after repeated flags in a short window.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "39.3",
          "status": "pending",
          "notes": "Server-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Enforce throttles on challenge creation and commenting within the affected GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "40",
      "status": "pending",
      "notes": "Standalone growth analytics; event-driven. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement an AARRR funnel pipeline that computes acquisition, activation, retention, referral, and revenue metrics per GeoCell and school.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "40.1",
          "status": "pending",
          "notes": "Schema only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Define a FunnelEvent schema with fields: user_id, event_type, cell_id, school_id, created_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "40.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Implement daily aggregation functions for AARRR stages based on event_type mappings.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "40.3",
          "status": "pending",
          "notes": "Output-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Generate JSON funnel reports per GeoCell (e.g., reports/funnel_<date>_<cell>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "41",
      "status": "pending",
      "notes": "Standalone retention analytics; pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement cohort retention calculator (D1/D3/D7/D14) for creators and viewers.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "41.1",
          "status": "pending",
          "notes": "Schema only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Define CohortKey with fields: cohort_date, user_id, role_type (viewer|creator).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "41.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add a retention calculator that outputs cohort tables for D1/D3/D7/D14.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "41.3",
          "status": "pending",
          "notes": "Output-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Write cohort tables to JSON (e.g., reports/cohorts_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "42",
      "status": "pending",
      "notes": "Standalone referral analytics; no dependency on rewards. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement k-factor computation and viral loop diagnostics using invite attribution events.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "42.1",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Compute k-factor as (invites sent × invite conversion rate) per GeoCell and school.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "42.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add loop diagnostics: time-to-invite, time-to-first-quest for invited users.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "42.3",
          "status": "pending",
          "notes": "Output-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Generate a daily viral report JSON with k-factor and loop timings.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "43",
      "status": "pending",
      "notes": "Standalone activation module; client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement a first-action activation prompt that fires after map view with a single-tap 'Start 60s quest' CTA.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "43.1",
          "status": "pending",
          "notes": "UI-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add a lightweight activation prompt banner on the map with one primary action.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "43.2",
          "status": "pending",
          "notes": "Client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Hook the banner to the Starter Quest flow to launch immediately.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "43.3",
          "status": "pending",
          "notes": "Analytics-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Track activation prompt impressions, clicks, and quest start rate.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "44",
      "status": "pending",
      "notes": "Standalone revenue analytics; config-driven. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement revenue attribution for PJM rewards and compute ARPU/LTV proxies per cohort.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "44.1",
          "status": "pending",
          "notes": "Schema only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Define RevenueEvent with fields: user_id, event_type, pjm_amount, usd_equivalent, created_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "44.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Compute ARPU and LTV proxies per cohort using RevenueEvent and retention tables.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "44.3",
          "status": "pending",
          "notes": "Output-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Generate daily revenue proxy reports in JSON (e.g., reports/revenue_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "45",
      "status": "pending",
      "notes": "Standalone growth-loop mapping; event-driven. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement a growth-loop mapper that assigns events to UGC, Viewer, and Social loops and computes loop health metrics.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "45.1",
          "status": "pending",
          "notes": "Config only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Create growth_loops.json mapping event types to loop stages (ugc_create, ugc_discover, viewer_watch, viewer_engage, social_invite, social_join).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "45.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Implement a loop aggregator that computes cycle completion rate and average time per loop.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "45.3",
          "status": "pending",
          "notes": "Output-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Generate daily loop health reports (e.g., reports/loops_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "46",
      "status": "pending",
      "notes": "Standalone reward variability engine; pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement a variable reward scheduler that selects reward types within bounded ranges to support habit formation without overspending.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "46.1",
          "status": "pending",
          "notes": "Config only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Create variable_rewards.json defining reward bundles (pjm_range, glow_duration_sec, badge_variant) and probabilities.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "46.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Implement a scheduler that selects a bundle per completion and enforces per-user daily caps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "46.3",
          "status": "pending",
          "notes": "Self-contained tests. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add tests to verify probability weights, cap enforcement, and deterministic output with a seed.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "47",
      "status": "pending",
      "notes": "Standalone ethics guard; client + config. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement notification budgets and quiet hours to prevent over-pressuring users.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "47.1",
          "status": "pending",
          "notes": "Config only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Create notification_policy.json with max_per_day, quiet_hours, and priority tiers.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "47.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Implement a notification budgeter that blocks or defers sends when limits are reached.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "47.3",
          "status": "pending",
          "notes": "Client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add user controls to mute categories and set personal quiet hours.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "48",
      "status": "pending",
      "notes": "Standalone experimentation framework; no dependency on other tasks. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement an A/B testing framework for reward amounts, glow duration, and quest types with assignment and exposure logging.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "48.1",
          "status": "pending",
          "notes": "Config only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Create experiments.json defining experiment ids, variants, and rollout percentages.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "48.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Implement deterministic user assignment using user_id hashing and variant weights.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "48.3",
          "status": "pending",
          "notes": "Analytics-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Log experiment exposures and variant outcomes to the event pipeline.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "49",
      "status": "pending",
      "notes": "Standalone referral asset generator; client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement a shareable local achievement card that embeds an invite link and GeoCell attribution.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "49.1",
          "status": "pending",
          "notes": "Client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Extend the share-card generator to include a QR code or deep link token tied to a GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "49.2",
          "status": "pending",
          "notes": "Client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add a card variant for streak milestones and local fame ranks.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "50",
      "status": "pending",
      "notes": "Standalone analytics; detects overjustification risk. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement an incentive-dependence monitor that tracks the ratio of reward-driven actions vs organic actions per user cohort.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "50.1",
          "status": "pending",
          "notes": "Schema only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Define IncentiveDependencyMetric with fields: cohort_date, reward_actions, organic_actions, ratio.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "50.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Compute daily ratios for new/warm/habitual tiers and flag high-dependence cohorts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "50.3",
          "status": "pending",
          "notes": "Output-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Generate a daily incentive-dependence report JSON (e.g., reports/incentive_dependency_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "51",
      "status": "pending",
      "notes": "Standalone starter bonus engine; server or client mock. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a first-quest starter bonus rule that awards PJM instantly on the first completed quest per day.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "51.1",
          "status": "pending",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create starter_bonus.json with fields: pjm_amount, max_per_day, cooldown_hours.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "51.2",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Implement a starter bonus validator that checks daily eligibility and returns awardable amount.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "51.3",
          "status": "pending",
          "notes": "Event-driven. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Emit a starter_bonus_awarded event on quest completion for analytics and budgeting.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "52",
      "status": "pending",
      "notes": "Standalone auto-quest bootstrap; no viewer dependency. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement an auto-quest bootstrapper that assigns a safe quest when a stream starts and no viewers are present.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "52.1",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Add a check that assigns a safe quest within the first N seconds of a new stream if viewer_count == 0.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "52.2",
          "status": "pending",
          "notes": "Client-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Display the auto-assigned quest in the stream overlay with a one-tap Done action.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "52.3",
          "status": "pending",
          "notes": "Analytics-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Track auto-quest assignment rate and completion rate.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "53",
      "status": "pending",
      "notes": "Standalone map visibility booster. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a first-quest map boost that highlights new streamers for a short window after completion.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "53.1",
          "status": "pending",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create map_boost.json with fields: boost_duration_sec, boost_style_variant, eligible_event_types.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "53.2",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Trigger a Glow Pin or Boost flag when a first-quest completion event is received.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "53.3",
          "status": "pending",
          "notes": "Analytics-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Track boost impressions and downstream viewer joins.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "54",
      "status": "pending",
      "notes": "Standalone pilot harness; config-driven. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a school pilot gate that enables the starter bonus + auto-quest + boost only for selected GeoCells.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "54.1",
          "status": "pending",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create pilot_geo_cells.json listing enabled GeoCells and rollout percentages.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "54.2",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Add a feature gate that checks GeoCell eligibility before applying starter bonus or auto-quest.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "54.3",
          "status": "pending",
          "notes": "Analytics-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Tag pilot events with geo_cell_id and rollout group for A/B evaluation.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "55",
      "status": "pending",
      "notes": "Standalone viral add-on; client-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a Fan Quest Chain prompt that appears after the first quest and encourages sharing for an extra visibility boost.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "55.1",
          "status": "pending",
          "notes": "UI-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Add a post-quest modal with one-tap share CTA and a preview of the extra boost reward.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "55.2",
          "status": "pending",
          "notes": "Client-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Implement a share action that attaches the user's GeoCell invite token to the share card/link.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "55.3",
          "status": "pending",
          "notes": "Analytics-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Track share attempts, successful shares, and downstream joins attributed to the Fan Quest Chain.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "56",
      "status": "pending",
      "notes": "Standalone A/B variants for the starter hack. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Add experiment variants that compare PJM vs Glow-only and solo vs school-duel modes for the first-quest flow.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "56.1",
          "status": "pending",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Extend experiments.json with variants: starter_pjm_vs_glow and starter_solo_vs_duel.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "56.2",
          "status": "pending",
          "notes": "Client-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Wire UI variants to show PJM reward vs Glow-only and solo vs school-duel banners.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "56.3",
          "status": "pending",
          "notes": "Analytics-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Log variant outcomes for activation, D1 creator retention, and streams per 1k users.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "57",
      "status": "pending",
      "notes": "Standalone metric pack; output-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a starter-hack KPI report covering first-stream rate, D1 creator retention, streams per 1k users, and boosted-to-organic ratio.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "57.1",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Compute first-stream rate within 24 hours of signup per GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "57.2",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Compute boosted-to-organic ratio: % of boosted streams that later occur without auto-quest or boost.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "57.3",
          "status": "pending",
          "notes": "Output-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Generate JSON report (e.g., reports/starter_hack_kpis_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "58",
      "status": "completed",
      "notes": "Standalone Blue Ocean analytics; config + scoring. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a Buyer Utility Map tool (buyer experience cycle × utility levers) with scoring and gap detection.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "58.1",
          "status": "completed",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create buyer_utility_map.json defining experience stages (purchase, delivery, use, supplements, maintenance, disposal) and utility levers (productivity, simplicity, convenience, risk, fun, environmental).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "58.2",
          "status": "completed",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Implement a scoring engine that assigns 1–5 scores per cell and detects low-scoring gaps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "58.3",
          "status": "completed",
          "notes": "Output-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Generate a JSON gap report highlighting top 5 utility opportunities.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "59",
      "status": "completed",
      "notes": "Standalone pricing tool; config + calculator. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a Price Corridor of the Mass calculator that recommends a strategic price range based on alternatives and substitutes.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "59.1",
          "status": "completed",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create price_corridor.json with competitor/alternative prices, tiers (low/mid/high), and buyer segments.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "59.2",
          "status": "completed",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Compute corridor bounds and recommend a strategic price point within the mass corridor.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "59.3",
          "status": "completed",
          "notes": "Output-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Generate a pricing recommendation report JSON with corridor bounds and rationale fields.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "60",
      "status": "completed",
      "notes": "Standalone cost tool; config + calculator. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a Target Costing calculator that derives target cost from strategic price and required margin.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "60.1",
          "status": "completed",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create target_costing.json with strategic_price, margin_target, and cost_components.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "60.2",
          "status": "completed",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Compute target_cost and allowable per-component budgets.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "60.3",
          "status": "completed",
          "notes": "Output-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Generate a target-cost report JSON with component budgets and gap-to-current-cost fields.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "61",
      "status": "pending",
      "notes": "Standalone adoption risk tooling; config + linter. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement an Adoption Hurdles checklist (cognitive, resource, motivational, political) and require each feature to declare mitigations.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "61.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create adoption_hurdles.json with required mitigation fields per hurdle type.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "61.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Add a linter that validates feature flags include mitigations for each hurdle type.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "61.3",
          "status": "pending",
          "notes": "CI-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Wire the adoption-hurdle linter into CI to block features without mitigation metadata.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "62",
      "status": "completed",
      "notes": "Standalone value innovation scoring; analytics-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement a Value Innovation Index that combines buyer utility gains, cost reductions, and differentiation signals.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "62.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create value_innovation_index.json defining weights for utility, cost, differentiation, and adoption friction.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "62.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Compute a composite score per feature or release from existing reports (utility gaps, cost targets, strategy canvas).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "62.3",
          "status": "completed",
          "notes": "Output-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Generate a value-innovation report JSON with ranked features and score deltas.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "63",
      "status": "completed",
      "notes": "Standalone differentiation guard; analytics-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement Strategy Canvas diagnostics to enforce focus, divergence, and a compelling tagline signal.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "63.1",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Compute focus and divergence scores from the strategy_canvas.json curves.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "63.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Add a tagline-fit checker that ensures at least one concise value statement can be derived from top curve peaks.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "63.3",
          "status": "completed",
          "notes": "Output-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Generate a differentiation report JSON with focus/divergence scores and tagline candidates.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "64",
      "status": "completed",
      "notes": "Bind reports to real analytics sources (GA4). Do not hardcode secrets; use env vars. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Add analytics source configuration for GA4 (account 372664399, property 510154368) and a fetcher that stores raw metrics for report pipelines.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "64.1",
          "status": "completed",
          "notes": "Config only; no secrets committed. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create config/analytics_sources.json with GA4 account/property IDs and required env vars (GA_ACCESS_TOKEN, GA_PROJECT_ID).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "64.2",
          "status": "completed",
          "notes": "Script-only; uses GA Data API. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement scripts/fetch_ga4_metrics.py to pull daily totals (users, sessions, eventCount) into reports/raw/ga4_<date>.json.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "64.3",
          "status": "completed",
          "notes": "Mapping only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create config/event_mapping.json to map GA4 events to internal events used by AARRR and loop reports.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "65",
      "status": "pending",
      "notes": "Report adapter layer; reads raw GA4 data and internal event logs. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Update report generators to consume real GA4 metrics + internal event mappings and persist normalized metrics for dashboards.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "65.1",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement a normalization step that converts GA4 raw metrics into internal daily metrics (dau, wau, mau, activation_rate).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "65.2",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Wire AARRR, cohort, and loop reports to read from normalized metrics plus event_mapping.json.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "65.3",
          "status": "pending",
          "notes": "Output-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Write normalized metrics to reports/normalized_metrics_<date>.json for dashboard consumption.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "66",
      "status": "completed",
      "notes": "Dashboard generation; JSON + SVG outputs. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Generate a one-page Blue Ocean dashboard (JSON + SVG) that aggregates strategy canvas, buyer utility gaps, AARRR, and loop health metrics.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "66.1",
          "status": "completed",
          "notes": "Schema only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Define dashboard schema (cards: value_curve, utility_gaps, aarr, loops, budget, local_fame).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "66.2",
          "status": "completed",
          "notes": "Script-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement scripts/build_blue_ocean_dashboard.py to read reports/*.json and output reports/blue_ocean_dashboard.json.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "66.3",
          "status": "completed",
          "notes": "SVG-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement an SVG renderer that produces reports/blue_ocean_dashboard.svg from the dashboard JSON.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "67",
      "status": "completed",
      "notes": "Standalone model to estimate chain-reaction thresholds (Jasper loop). Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement a viral chain reaction simulator that estimates required seed creators per GeoCell to reach a target stream volume within a time window.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "67.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create viral_model_inputs.json with parameters: avg_viewers_per_stream, view_to_creator_rate, creator_activation_rate, streams_per_creator_per_day, time_window_hours, target_streams.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "67.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement a branching-process estimator to compute R0 = avg_viewers_per_stream × view_to_creator_rate × creator_activation_rate.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "67.3",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Compute required seed creators N0 for a target stream volume given R0 and streams_per_creator_per_day.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "67.4",
          "status": "completed",
          "notes": "Output-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Generate reports/viral_seed_estimate_<date>.json with N0, R0, and sensitivity ranges.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "68",
      "status": "completed",
      "notes": "Standalone budget optimizer; uses PJM cost. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement a launch budget optimizer that converts seed creator requirements into PJM and USD budgets for a one-day citywide launch.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "68.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create launch_budget_inputs.json with pjm_usd_rate, starter_reward_pjm, boost_reward_pjm_equivalent, and max_pjm_per_creator.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "68.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Compute total PJM + USD required for N0 seed creators and apply safety margin multipliers (1.2x, 1.5x).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "68.3",
          "status": "completed",
          "notes": "Output-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Generate reports/launch_budget_estimate_<date>.json with low/base/high budget scenarios.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "69",
      "status": "completed",
      "notes": "Standalone trend detector; event-driven. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement a local trend detector that flags when a GeoCell crosses a stream-rate threshold and triggers map visibility boosts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "69.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create trend_thresholds.json with streams_per_hour, unique_creators_per_hour, and sustained_window_minutes.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "69.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement a detector that computes rolling stream rates and emits trend flags per GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "69.3",
          "status": "completed",
          "notes": "Event-driven. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Trigger a temporary boost and tag events with trend_id for post-analysis.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "70",
      "status": "completed",
      "notes": "Standalone seeding config; no external dependencies. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Add a Bangkok pilot seeding map with GeoCell groups and launch waves to coordinate simultaneous activation.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "70.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create bangkok_launch_waves.json with wave_id, geo_cell_ids, and target_seed_creators.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "70.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement a wave scheduler that activates starter-hack features by wave and logs activation timestamps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "71",
      "status": "completed",
      "notes": "Standalone experiment pack for Jasper hack strength. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement a Jasper-hack strength experiment comparing: (A) PJM+Glow, (B) Glow-only, (C) Glow+TrendBoost during launch hour.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "71.1",
          "status": "completed",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Extend experiments.json with jasper_strength variants and rollout weights.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "71.2",
          "status": "completed",
          "notes": "Analytics-only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Log activation, D1 retention, and k-factor per variant for launch-hour cohorts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "72",
      "status": "pending",
      "notes": "Turns Jasper loop into a real launch seeding pipeline. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement a seed-creator acquisition playbook config and task generator for initial launch seeding.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "72.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create seed_creator_sources.json with schools/clubs/ambassadors and target counts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "72.2",
          "status": "pending",
          "notes": "Pure generation logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement generate_seed_tasks.py to output outreach task lists (JSON/CSV) by GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "72.3",
          "status": "pending",
          "notes": "Schema only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Define seed_tracking_schema.json for attribution fields (source_id, status, first_stream_at).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "73",
      "status": "pending",
      "notes": "Safety layer required for school-scale launch. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement teen-safe content policy pack: policy config, linter, and moderation playbook report.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "73.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create content_policy.json with allowed/disallowed categories, severity, and actions.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "73.2",
          "status": "pending",
          "notes": "Pure logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement policy_linter.py to validate rule coverage and detect conflicting policies.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "73.3",
          "status": "pending",
          "notes": "Report output. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Generate moderation_playbook_<date>.json from policy with summary actions and escalation paths.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "74",
      "status": "pending",
      "notes": "Creates the external reason to go live layer. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement ritual campaign scheduler and shareable asset generator for recurring launch windows.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "74.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create ritual_campaigns.json with weekly themes, time windows, and GeoCells.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "74.2",
          "status": "pending",
          "notes": "Pure logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement schedule_ritual_campaigns.py to output active campaign windows per date.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "74.3",
          "status": "pending",
          "notes": "Asset generation only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement generate_campaign_assets.py to output share text/templates for campaigns.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "75",
      "status": "pending",
      "notes": "Encodes the Jasper myth-building layer. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement narrative loop toolkit to turn first streams into shareable local stories.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "75.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create narrative_templates.json for first-stream, local hero, and school rival narratives.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "75.2",
          "status": "pending",
          "notes": "Local rendering only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement generate_story_cards.py to produce SVG/PNG story cards with local stats.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "75.3",
          "status": "pending",
          "notes": "Mapping only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Add narrative_event_mapping.json to log share triggers for analytics attribution.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "76",
      "status": "pending",
      "notes": "Bridges internal trends to external visibility. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement external trend amplification pack for exporting trend payloads to external channels.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "76.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create external_trend_targets.json (hashtags, platform targets, export formats).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "76.2",
          "status": "pending",
          "notes": "Pure generation logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement export_trend_payloads.py to generate upload packages from trend flags.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "76.3",
          "status": "pending",
          "notes": "Schema only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create external_trend_log.json schema to manually log external pickups for analysis.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "77",
      "status": "pending",
      "notes": "Defines the success criteria for Jasper ignition. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement launch KPI thresholds and blast-detection report for nuclear start validation.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "77.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create launch_kpi_thresholds.json with streams_per_30min, creators_per_hour, viewer_to_creator_rate, and trend_flags.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "77.2",
          "status": "pending",
          "notes": "Pure logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement detect_launch_blast.py to evaluate raw events against KPI thresholds.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "77.3",
          "status": "pending",
          "notes": "Report output. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Generate launch_blast_report_<date>.json with pass/fail and confidence score.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "78",
      "status": "pending",
      "notes": "Adds the external resource engine analogous to Klaus. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement partnership trigger layer for coordinated activations with local partners.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "78.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create partner_triggers.json with partner_id, reward pool, activation window, and target GeoCells.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "78.2",
          "status": "pending",
          "notes": "Pure logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement schedule_partner_triggers.py to activate partner windows and log events.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "78.3",
          "status": "pending",
          "notes": "Report output. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Generate partner_trigger_report_<date>.json summarizing active partners and spend caps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "79",
      "status": "pending",
      "notes": "Covers alternatives, strategic groups, buyer chain, complements, functional/emotional, trends. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement Six Paths Framework report: systematically reconstruct market boundaries.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "79.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create six_paths_inputs.json with competitor/alternative sets and assumptions.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "79.2",
          "status": "pending",
          "notes": "Pure generation logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement build_six_paths_report.py to generate a structured six-paths analysis JSON.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "79.3",
          "status": "pending",
          "notes": "Report output. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Generate reports/six_paths_<date>.json and a short summary JSON for dashboard.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "80",
      "status": "pending",
      "notes": "Adds field-testing and validation loops per BOS. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement Visual Strategy Process artifacts (Awakening → Exploration → Strategy Fair → Communication).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "80.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create visual_strategy_stages.json with stage checklists and required evidence fields.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "80.2",
          "status": "pending",
          "notes": "Pure logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement visual_strategy_tracker.py to record stage completion and evidence links.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "80.3",
          "status": "pending",
          "notes": "Report output. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Generate reports/visual_strategy_status_<date>.json and a printable summary HTML.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "81",
      "status": "pending",
      "notes": "Maps features/releases into BOS portfolio health view. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Pioneer–Migrator–Settler (PMS) map for portfolio classification.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "81.1",
          "status": "pending",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create pms_map_inputs.json with feature list and classification criteria.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "81.2",
          "status": "pending",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement build_pms_map.py to classify features and compute portfolio balance.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "81.3",
          "status": "pending",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/pms_map_<date>.json and an SVG visual snapshot.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "82",
      "status": "pending",
      "notes": "Captures cognitive, resource, motivational, and political hurdles with actions. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Tipping Point Leadership checklist and constraint map.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "82.1",
          "status": "pending",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create tipping_point_hurdles.json with hurdle definitions and action templates.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "82.2",
          "status": "pending",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement build_tipping_point_plan.py to output a prioritized action list.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "82.3",
          "status": "pending",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/tipping_point_plan_<date>.json and summary for dashboard.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "83",
      "status": "pending",
      "notes": "Ensures BOS execution discipline. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Fair Process checklist (engagement, explanation, expectation clarity) for key initiatives.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "83.1",
          "status": "pending",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create fair_process_checklist.json with required fields and thresholds.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "83.2",
          "status": "pending",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement fair_process_audit.py to validate initiative records against checklist.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "83.3",
          "status": "pending",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/fair_process_audit_<date>.json with pass/fail and gaps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "84",
      "status": "pending",
      "notes": "Formalizes execution layer referenced in BOS. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Execution-into-Strategy integration report (link initiatives to metrics, owners, and timelines).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "84.1",
          "status": "pending",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create execution_integrations.json with initiative_id, owner, metrics, and timeline.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "84.2",
          "status": "pending",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement build_execution_map.py to output readiness score and dependency graph JSON.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "84.3",
          "status": "pending",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/execution_map_<date>.json and dashboard summary fields.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "85",
      "status": "completed",
      "notes": "BOS sustainability/renewal layer. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Sustainability & Renewal module to monitor imitation barriers and strategy drift.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "85.1",
          "status": "completed",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create imitation_barriers.json with factors (legal, brand, network effects, costs, data).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "85.2",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement assess_imitation_barriers.py to score barriers and output a risk index.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "85.3",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement strategy_drift_monitor.py to compare strategy_canvas snapshots and flag drift.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "85.4",
          "status": "completed",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/sustainability_<date>.json with barrier index and drift flags.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "86",
      "status": "completed",
      "notes": "Explicit BOS risk assessment module. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement BOS Risk Matrix (search/planning/scale/business model/organizational/management risks).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "86.1",
          "status": "completed",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create bos_risk_matrix.json with risk categories, scoring scale, and mitigation fields.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "86.2",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement assess_bos_risks.py to compute weighted risk scores.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "86.3",
          "status": "completed",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/bos_risk_<date>.json with scores and top mitigation gaps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "87",
      "status": "completed",
      "notes": "Connects value innovation to cost structure. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Cost Driver Map linking ERRC factors to cost components and savings estimates.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "87.1",
          "status": "completed",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create cost_driver_map.json with ERRC factors, cost drivers, and expected impact ranges.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "87.2",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement compute_cost_driver_impact.py to estimate net cost delta.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "87.3",
          "status": "completed",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/cost_driver_impact_<date>.json with savings/risk summary.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "88",
      "status": "completed",
      "notes": "Adds real-world validation layer to Six Paths. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement External Validation Inputs pack for buyer chain and complementor field testing.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "88.1",
          "status": "completed",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create validation_inputs.json with interview targets, sample size, and hypothesis list.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "88.2",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement validate_field_tests.py to ingest results and compute confidence scores.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "88.3",
          "status": "completed",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/field_validation_<date>.json with evidence coverage and confidence.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "89",
      "status": "completed",
      "notes": "Prevents red-ocean drift. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Value Curve Drift Monitoring report to track focus/divergence over time.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "89.1",
          "status": "completed",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create value_curve_drift_config.json with thresholds for focus/divergence decline.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "89.2",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement detect_value_curve_drift.py to compare historical strategy_canvas snapshots.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "89.3",
          "status": "completed",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/value_curve_drift_<date>.json with alerts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    }
  ]
}
