{
  "tasks": [
    {
      "number": "1",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать отдельный Python‑скрипт генерации контента под новое позиционирование и сделать его пригодным для пакетной обработки страниц. Здесь нужно не просто сформировать текст, а построить воспроизводимый пайплайн: на входе — структурированный JSON с профилем позиционирования (ценностные оси, тональность, ограничения, обязательные дисклеймеры) и список URL/страниц; на выходе — строгий JSON‑маппинг полей (Meta Title, Hero, Content Notes, CTA/Modules, HTML‑фрагменты), готовый к дальнейшему применению. В рамках задачи требуется: определить модель входных данных, сделать валидацию обязательных полей (например: profile.name, tone, pages[].url), нормализовать ввод (трим, уникализация URL, дефолтные значения), собрать контентные шаблоны под ключевые оси позиционирования (подписка‑подарок, гурманский набор, ограниченность/ответственное потребление, социальная игра), и применить их детерминированно или с конфиг‑переменными. Результат должен быть детерминированным: одинаковый ввод → одинаковый вывод. Скрипт должен писать JSON с четкой схемой полей, чтобы следующий шаг мог безошибочно применить обновления. Важно описать в коде правила длины для title/hero/cta, предусмотреть fallback‑текст, а также поддержку нескольких языков (минимум ключ для языка, даже если пока используется один). Выходной JSON должен содержать для каждой страницы ссылку на оригинальный URL, версии контента, и метаданные генерации (дата, версия шаблона). Эта задача — основа всего контентного обновления: без строгой схемы и шаблонов нельзя автоматизировать дальнейшие шаги.",
      "subtasks": [
        {
          "number": "1.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Определить формат входного JSON и реализовать его валидацию. Нужно явно описать, какие поля обязательны и как они должны выглядеть: например, profile (объект), tone (строка), pages (массив объектов), pages[].url (строка), pages[].intent (строка), key_points (массив). Дополнительно стоит предусмотреть опциональные поля для расширения: locale, restrictions, brand_terms, banned_phrases, mandatory_disclaimer. Валидация должна проверять: типы данных, пустые значения, дубликаты URL, наличие ключевых полей, корректность структуры массива страниц. Ошибки валидации должны быть читаемыми и указывать путь к полю (например: pages[3].url). Если данные некорректны, скрипт должен завершаться с понятным сообщением и кодом ошибки. Также нужно нормализовать значения: убрать пробелы, привести URL к каноническому виду, задать дефолты. Это обеспечит стабильность дальнейшей генерации и исключит разъезды между входом и выходом.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "1.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "1.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать библиотеку шаблонов копирайта под три ключевые смысловые оси. Необходимо сформировать минимум по 3–5 шаблонов на каждую ось: subscription‑gift (подписка как подарок), gourmet‑tasting (вкусовой набор и дегустация), small‑quantity/positive‑social (ограниченность, ответственное потребление, игра с друзьями). Каждый шаблон должен иметь структуру: заголовок/подзаголовок/описание/CTA, и поддерживать параметризацию (например: сезон, регион, число бутылок, тональность). Шаблоны должны учитывать ограничения по длине для мета‑полей и CTA. Также важно предусмотреть правила комбинирования осей: например, основной акцент на подарке, но вторичная вставка про дегустацию. В коде нужно реализовать механизм выбора шаблона (по intent страницы или по набору ключевых точек) и генерации итогового текста. Результат должен быть логичным и не повторяться между страницами при одинаковых входных данных.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "1.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "1.3",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сформировать выходной JSON‑маппинг по каждому URL. Задача — превратить шаблонный текст в чёткую структуру данных, пригодную для применения к CSV: поля Meta Title, Hero / Content Notes, CTA / Modules, HTML‑фрагмент. Нужно обеспечить единый формат ключей: например meta_title, hero_title, hero_subtitle, content_notes, cta_primary, modules_html. Для каждой страницы должны быть указаны исходный URL, дата генерации, версия шаблона, а также маркер языка/локали. Дополнительно стоит включить поле warnings, если текст не помещается в ограничения по длине. Выходной JSON должен быть валидируемым, чтобы следующий скрипт мог применить значения без ручной проверки. Обязательно протестировать на 2–3 фиктивных страницах, чтобы убедиться в корректности структуры.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "1.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "1.4",
          "status": "pending",
          "notes": "",
          "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
          "subtasks": []
        },
        {
          "number": "1.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 1 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "2",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать Python‑скрипт, который применяет JSON‑маппинг к исходному CSV. Цель — автоматизировать обновление контента в структурном файле без ручной правки. Скрипт должен читать CSV с сохранением порядка колонок и кодировкой, находить строки по URL, обновлять конкретные поля и записывать новый CSV. Важно реализовать защиту: если URL из JSON не найден в CSV — фиксировать это в отчёте; если поля отсутствуют — выводить ошибку. Скрипт должен поддерживать dry‑run (только отчёт без записи) и выводить summary: сколько строк обновлено, сколько пропущено, какие поля изменены. Нужно обеспечить, чтобы обновления не ломали формат CSV и не меняли другие колонки. Этот шаг критичен, потому что именно здесь контент реально попадает в рабочий файл.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "2.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать корректное чтение CSV с сохранением структуры. Нужно определить разделитель (запятая/точка с запятой), обработать BOM, корректно поддерживать UTF‑8 и UTF‑8‑SIG. Скрипт должен загружать CSV в память с сохранением порядка колонок и оригинальных имён. Важно не потерять пустые значения и не изменить порядок строк. Также стоит предусмотреть аргумент командной строки для указания явного разделителя, если автоопределение ошибается.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "2.1.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "2.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать логику поиска строк по URL и обновления полей. Нужно сравнивать URL из JSON‑маппинга со столбцом URL в CSV, при необходимости нормализовать (убрать слэш, привести к нижнему регистру). После нахождения строки — обновить только целевые колонки (Meta Title, Hero / Content Notes, CTA / Modules, HTML). Если JSON содержит поле, которого нет в CSV — вывести предупреждение. Также нужно поддержать режим частичного обновления (например, только meta_title и hero).\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "2.2.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "2.3",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сохранить CSV и сформировать итоговый отчёт. Скрипт должен писать новый CSV (либо поверх исходного, либо в новый путь), сохраняя кодировку и разделитель. После записи вывести summary: сколько URL обновлено, сколько не найдено, какие поля изменялись. Отчёт должен быть также доступен в JSON‑виде, чтобы его можно было использовать в последующих шагах (например, для HTML‑отчёта).\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "2.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "2.4",
          "status": "pending",
          "notes": "",
          "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
          "subtasks": []
        }
      ]
    },
    {
      "number": "3",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать Python‑скрипт генерации Google Ads RSA ассетов под новое позиционирование. Нужно сформировать набор заголовков и описаний, которые соответствуют требованиям RSA: headlines до 30 символов, descriptions до 90. Шаблоны должны отражать ключевые оси ценности (подарок, дегустация, ответственность) и быть разнообразными по формулировке. Скрипт должен уметь удалять дубликаты, проверять длины, выдавать финальный список в CSV/JSON формате, пригодном для импорта в Google Ads. Также полезно включить параметризацию по языку и региону. Это позволит запускать кампании без ручной генерации ассетов.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "3.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Задать библиотеку шаблонов заголовков и описаний. Нужно минимум 15–20 headline‑вариантов и 6–10 descriptions, разделённых по смысловым группам (gift, tasting, small‑quantity, social game). Каждый шаблон должен быть записан так, чтобы укладываться в ограничения по длине даже после подстановки переменных. Рекомендуется создать словарь переменных (например: season, city) и правила их замены. Шаблоны должны быть реалистичными для рекламы, без запрещённых обещаний.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "3.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "3.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать валидатор длины и уникальности. Скрипт должен считать длину строк, отбрасывать варианты, превышающие лимиты, и фиксировать это в отчёте. Также необходимо удалять дубликаты (case‑insensitive), чтобы не было повторов в RSA. Результатом должна быть чистая, валидная коллекция ассетов.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "3.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "3.3",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Экспортировать ассеты в CSV/JSON, пригодные для импорта. CSV должен содержать тип ассета, текст, опционально label. JSON — массив объектов. Нужно добавить метаданные: версия шаблона, дата генерации. Это позволит в любой момент пересобрать ассеты и сравнить версии.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "3.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "3.4",
          "status": "pending",
          "notes": "",
          "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
          "subtasks": []
        }
      ]
    },
    {
      "number": "4",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать Python‑скрипт генерации FAQ и ответов на возражения. FAQ должен отражать главные сомнения пользователей о подписке, подарке, доставке и безопасном употреблении. Скрипт должен брать входные параметры (страна, сезон, набор) и собирать готовые HTML‑фрагменты FAQ для каждой страницы. Важно формировать не только Q/A, но и корректную разметку, чтобы вставка в страницу была простой и стандартизированной.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "4.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Создать набор шаблонов вопросов и ответов. Нужно минимум 8–12 Q/A, с параметрами (сезон, страна, количество бутылок, формат подарка). В шаблонах должны быть предусмотрены дисклеймеры 21+ и корректная формулировка без мед. обещаний.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "4.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "4.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Экспортировать HTML‑фрагменты FAQ в JSON‑маппинг по URL. Для каждой страницы должен быть блок FAQ с готовой разметкой. Формат должен быть совместим с дальнейшим применением в CSV/контент‑платформе.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "4.2.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "4.3",
          "status": "pending",
          "notes": "",
          "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
          "subtasks": []
        }
      ]
    },
    {
      "number": "5",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать скрипт комплаенс‑проверки контента. Он должен автоматически искать обязательные дисклеймеры 21+, выявлять рискованные формулировки (например, обещания здоровья/лечения), и формировать отчёт по каждой странице. Цель — снизить юридические риски и обеспечить соответствие правилам алкогольной рекламы.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "5.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать набор регэксп‑правил для поиска дисклеймеров и рискованных фраз. Правила должны быть расширяемыми, список хранится в конфиге. Должно быть разделение на ошибки и предупреждения.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "5.1.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "5.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сформировать отчёт по URL: missing_age_gate, risky_health_claims, promote_overconsumption и др. Отчёт должен быть в JSON и пригоден для включения в общий HTML‑репорт.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "5.2.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "5.3",
          "status": "pending",
          "notes": "",
          "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
          "subtasks": []
        }
      ]
    },
    {
      "number": "6",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать CLI‑скрипт архивирования CSV. Перед любым обновлением файл должен копироваться в архивную папку с таймстампом. Это позволяет откатить изменения и иметь историю обновлений.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "6.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать CLI‑аргументы: --input, --archive-dir, --prefix. Скрипт должен работать как с абсолютными путями, так и с относительными.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "6.1.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "6.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сформировать имя архива с ISO‑таймстампом и безопасными символами. Важно исключить пробелы, двоеточия и другие проблемные символы для файловых систем.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "6.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "6.3",
          "status": "pending",
          "notes": "",
          "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
          "subtasks": []
        }
      ]
    },
    {
      "number": "7",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать Python‑скрипт валидации структуры CSV. Цель — убедиться, что обязательные колонки присутствуют, нет дублей URL, а структура соответствует ожиданиям генераторов контента.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "7.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Автоопределение разделителя CSV и корректная обработка кодировок. Скрипт должен уметь корректно читать файлы с BOM и без него.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "7.1.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "7.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Проверить обязательные колонки: Published, Page, URL, Intent, Target Keywords, Meta Title и др. Если чего‑то нет — формировать ошибку.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "7.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "7.3",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сформировать JSON‑отчёт по ошибкам и предупреждениям. Отчёт должен быть пригоден для включения в итоговый HTML‑репорт.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "7.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "7.4",
          "status": "pending",
          "notes": "",
          "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
          "subtasks": []
        }
      ]
    },
    {
      "number": "8",
      "status": "completed",
      "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Создать генератор HTML‑отчёта по итогам обновлений. Отчёт должен включать список обновлённых URL, изменения по полям, предупреждения комплаенса и метрики. Это нужно для визуальной проверки качества автоматизации.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "8.1",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Сделать HTML‑шаблон с секциями: Copy Updates, FAQ Updates, Ad Assets, Compliance, Summary. Шаблон должен быть читаемым и пригодным для передачи стейкхолдерам.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "8.1.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "8.2",
          "status": "completed",
          "notes": "Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Реализовать CLI‑параметры: --data-json, --out-html, --title, --date. Скрипт должен уметь собирать отчёт из разных JSON‑файлов.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": [
            {
              "number": "8.2.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "8.3",
          "status": "pending",
          "notes": "",
          "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
          "subtasks": []
        }
      ]
    },
    {
      "number": "9",
      "status": "pending",
      "notes": "Standalone client feature; no dependency on other tasks. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Implement a self‑contained Starter Quest flow in the client. Нужно реализовать локальный (offline/mock) контур: каталог квестов, выбор подходящего квеста, запуск таймера, и завершение с отображением результата. Это ядро Джеспер‑механики: пользователь сразу получает задание без ожидания зрителей. Минимальная реализация должна работать в dev‑режиме без бэка, чтобы тестировать UX.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "9.1",
          "status": "pending",
          "notes": "Data-only task; safe to do first or last. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Add local quest catalog file with at least 20 safe quests. Каталог должен содержать id, текст задания, safe_tags, длительность и возрастные ограничения. Этот файл — источник всех auto‑quests для старта.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "9.2",
          "status": "pending",
          "notes": "Type definitions only. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Create quest type definitions. Нужно типизировать Quest, QuestCategory, QuestSafety и т.д., чтобы остальные части кода могли безопасно работать с заданиями.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "9.3",
          "status": "pending",
          "notes": "Pure logic function; unit-testable. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Add a quest selection function that filters by safe_tags and locale. Алгоритм должен учитывать возраст, локацию, избегать повторов и выбирать безопасные задания.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "9.4",
          "status": "pending",
          "notes": "No backend dependency; local state only. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Implement useStarterQuest hook/state machine. Логика: start → countdown → complete → emit event. Должны быть переходы на cancel/timeout, а также защита от двойного старта.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "9.5",
          "status": "pending",
          "notes": "UI overlay only. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Add in‑stream overlay component. Он показывает текст задания, таймер, кнопку Done, и краткий статус. UI должен быть минимальным и не перекрывать основной стрим.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "10",
      "status": "pending",
      "notes": "Standalone UI feature; can be implemented without server changes. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
      "description": "Add Glow Pin map overlay with TTL. Нужно визуально подсветить активные стартовые стримы на карте и автоматически убирать подсветку по истечении времени. Это основа социального заражения: другие видят “светящийся пин” и включаются.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
      "subtasks": [
        {
          "number": "10.1",
          "status": "pending",
          "notes": "Data model only. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Define GlowPin model with id, lat/lng, started_at, ttl_sec, style. Модель нужна для рендера и контроля времени жизни.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "10.2",
          "status": "pending",
          "notes": "UI-only task. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Create GlowPin layer/component with pulse animation. Нужно обеспечить заметную, но не агрессивную подсветку на карте.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "10.3",
          "status": "pending",
          "notes": "Simple timer cleanup. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Add TTL expiry logic to remove pins. Это может быть таймер или периодическая проверка времени.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "10.4",
          "status": "pending",
          "notes": "Local demo only. Цель этой задачи — сделать шаг воспроизводимым и прозрачным: мы хотим не просто выполнить действие, а зафиксировать логику, чтобы результат можно было повторить, проверить и масштабировать. Выполнение пункта даёт понятный артефакт (конфиг/скрипт/отчёт), который снижает риск ошибок, ускоряет следующие этапы и делает процесс управляемым. Подход: фиксируем входные данные, задаём критерии готовности, реализуем проверяемый выход. Ожидаемый результат — чёткий, измеримый и пригодный для интеграции в общий пайплайн планирования. Это важно, потому что без такого шага последующие задачи теряют связность и становятся ручными.",
          "description": "Add dev‑only toggle/mock data. Должна быть возможность включить тестовые пины без реальных стримов для проверки UI.\n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. \n\nПодробности выполнения: 1) Подготовка: собрать все входные данные, определить формат ввода/вывода, зафиксировать ограничения по длинам и форматам. 2) Реализация: написать функции обработки, учесть edge‑cases (пустые значения, дубликаты, некорректные типы), добавить нормализацию и защиту от ошибок. 3) Проверка: сделать минимум один позитивный и один негативный тест‑кейс, убедиться, что ошибка читабельна и не ломает остальные данные. 4) Риски: зафиксировать, что будет при неполных данных, и как обрабатываются частичные обновления; добавить дефолты. 5) Готовность: критерий — повторяемый результат, понятный отчёт и отсутствие скрытых изменений вне целевых полей. ",
          "subtasks": []
        },
        {
          "number": "10.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 10 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "11",
      "status": "pending",
      "notes": "Standalone UI feature; no backend dependency required. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Implement an instant reward UI: a toast plus a shareable card generated on the client after quest completion.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "11.1",
          "status": "pending",
          "notes": "UI-only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Create a RewardToast component that shows reward name, amount (optional), and a short confirmation.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "11.2",
          "status": "pending",
          "notes": "Pure client utility. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a share-card generator (canvas/SVG) that renders quest title, Glow Pin badge, and timestamp.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "11.3",
          "status": "pending",
          "notes": "No external integrations required. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a client-only share flow that saves the card as an image file or opens a native share sheet when available.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "12",
      "status": "pending",
      "notes": "Standalone shared module; safe to implement independently. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.\n\nПочему такой выбор: off‑campus+after‑school минимизирует барьеры согласований и юридические риски, оставляя эффект «рядом со школой»; private‑first даёт быстрые договорённости и символический престиж, который запускает эффект подражания; co‑ed фокус ускоряет «склейку» сетей и снижает фрагментацию аудитории. Публичные школы подключаем во 2‑й волне, когда есть доказанный эффект и кейсы для администраций.",
      "description": "Create a local After-School Rush scheduler that determines whether the current time is within a configured daily window.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений.\n\nРЕШЕНИЕ ДЛЯ ПИЛОТА (принято здесь и дальше используется как норматив): (1) запуск ТОЛЬКО после уроков и ВНЕ территории школы — off-campus geofence 300–600м вокруг кампуса; on-campus допускается только при отдельном письменном разрешении/партнёрстве; (2) тип школ для старта: private‑first (быстрее согласования и сильнее символический статус), public — волна 2 после подтверждения метрик; (3) аудитория: co‑ed по умолчанию (максимальная сеть и межклассные эффекты), а для single‑sex школ применяются те же механики, но с адаптированными квестами/креативами. Эти параметры должны быть закодированы в конфигах и проверяться в рантайме.",
      "subtasks": [
        {
          "number": "12.1",
          "status": "pending",
          "notes": "Config only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a schedule config file (e.g., config/rush_schedule.json) with per-locale start/end times and timezone.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "12.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a function (e.g., isRushActive(now, locale)) that returns true/false and minutes remaining.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "12.3",
          "status": "pending",
          "notes": "Self-contained tests. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add unit tests covering boundary times, daylight saving edge cases, and incorrect locale values.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "12.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 12 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "13",
      "status": "pending",
      "notes": "Standalone persistence module; implement with local storage or a small DB table. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Implement streak tracking for creators: update streak on quest completion, compute current streak, and expose streak status for UI.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "13.1",
          "status": "pending",
          "notes": "Data model only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a Streak record model with fields: user_id, current_streak, last_completed_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "13.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement updateStreak(user_id, completed_at) with correct day-boundary handling.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "13.3",
          "status": "pending",
          "notes": "Optional feature; keep independent. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add an optional streak-freeze flag that preserves streak for a single missed day.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "13.4",
          "status": "pending",
          "notes": "Thin API layer. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Expose a getStreakStatus(user_id) helper that returns current streak and next deadline.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "13.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 13 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "14",
      "status": "pending",
      "notes": "Standalone aggregation module; no dependency on other features. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Implement a daily school leaderboard aggregator that ranks schools by completed quests within a time window.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "14.1",
          "status": "pending",
          "notes": "Schema only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Define a QuestCompletionEvent with fields: event_id, user_id, school_id, completed_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "14.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a daily aggregation function that counts completions per school for a given date.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "14.3",
          "status": "pending",
          "notes": "Simple API. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a read-only endpoint or function that returns Top-N schools with counts and rank.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "14.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 14 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Houseparty: волна хайпа не превратилась в устойчивый ритуал и продукт угас. Мы должны анализировать не только школы/волны, которые взлетели, но и те, что не дали эффекта. Нужна карта «failed waves»: какие окна, какие квесты, какой seed‑level. Сравниваем их с успешными волнами, корректируем расписание, плотность seed‑создателей, тип наград и ритуалов. Итог: стратегия запуска усиливается за счёт анализа провалов, и риск одноразового всплеска минимизируется. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "15",
      "status": "pending",
      "notes": "Standalone backend guard; does not require UI changes. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Add an anti-fraud validator for quest completion that enforces minimum stream duration and basic rate limits.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "15.1",
          "status": "pending",
          "notes": "Pure validation logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement min-duration validation (e.g., >= 45 seconds) before accepting quest completion.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "15.2",
          "status": "pending",
          "notes": "Local-only rate limit. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add per-device or per-user daily cap for starter rewards (e.g., 1/day).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "15.3",
          "status": "pending",
          "notes": "Heuristic rule; no ML. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a duplicate-content heuristic that flags repeated completions with identical duration and metadata.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "15.4",
          "status": "pending",
          "notes": "Audit trail only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Persist fraud flags to an audit log for later review.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "16",
      "status": "pending",
      "notes": "Standalone analytics module; can be added without other features. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Add client and server event logging for quest start, quest completion, glow awarded, and streak updated.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "16.1",
          "status": "pending",
          "notes": "Constants only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Define event names and payload schemas in a shared constants file.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "16.2",
          "status": "pending",
          "notes": "Client-only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a client event emitter with batching and a retry queue.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "16.3",
          "status": "pending",
          "notes": "Server-only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a simple server endpoint to accept events and write them to storage.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "16.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 16 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "17",
      "status": "pending",
      "notes": "Standalone config + pure calculation; no dependencies. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Add a reward budget configuration and calculator module that uses a fixed conversion rate (1 PJM = $0.01) to compute daily and monthly USD spend caps per school.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "17.1",
          "status": "pending",
          "notes": "Config only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Create a reward budget config file (e.g., config/reward_budget.json) with fields: pjm_usd_rate, daily_cap_per_school_pjm, per_user_daily_cap_pjm, and category_allocations (starter, streak, referral, rush).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "17.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement a calculator function that returns daily and monthly USD caps per school and total network cap for N schools.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "17.3",
          "status": "pending",
          "notes": "Self-contained tests. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add unit tests for conversion accuracy and rounding rules using 1 PJM = $0.01.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "17.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 17 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "18",
      "status": "pending",
      "notes": "Standalone allocation engine; pure functions. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Implement a reward allocation engine that computes PJM payouts per event type (starter quest, streak milestones, referral quality, rush pool).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "18.1",
          "status": "pending",
          "notes": "Constants only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Define reward event types and default payout values (starter_quest, streak_d1, streak_d3, streak_d7, referral_new_user, referral_retained, rush_ranked).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "18.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement allocation for Starter Quest with a fixed payout (default 10 PJM) and a one-per-day constraint enforced by caller context.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "18.3",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement allocation for streak milestones (D1=15 PJM, D3=25 PJM, D7=100 PJM) with milestone detection handled by caller context.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "18.4",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement referral allocation with two-stage payouts (new_user_completion and retained_day2) returning separate rewards.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "18.5",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement rush pool distribution for Top-N ranks using a configurable payout table and a fixed pool size.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "18.6",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 18 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "19",
      "status": "pending",
      "notes": "Standalone budget guard; can wrap any allocator. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Add budget guard logic that enforces per-school daily caps, per-user daily caps, and soft throttling when spend reaches 80% of the daily cap.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "19.1",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement per-school daily cap enforcement that rejects or reduces rewards once the cap is reached.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "19.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement per-user daily cap enforcement that blocks rewards after the user reaches the daily max.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "19.3",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement soft throttling: when school spend exceeds 80% of the daily cap, reduce rewards by a configurable factor.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "19.4",
          "status": "pending",
          "notes": "Self-contained tests. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add unit tests covering cap enforcement and throttling behavior at 80% and 100% thresholds.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "19.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 19 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "20",
      "status": "pending",
      "notes": "Standalone accounting module; no runtime dependency on other tasks. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
      "description": "Implement a reward payout ledger and daily rollups to track PJM spend per school and per user.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "20.1",
          "status": "pending",
          "notes": "Schema only. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Define RewardPayoutEvent with fields: event_id, user_id, school_id, reward_type, pjm_amount, created_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "20.2",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Implement daily rollup functions to compute total PJM spent per school and per user for a given date.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "20.3",
          "status": "pending",
          "notes": "Pure logic. Цель этого пункта — обеспечить устойчивость процесса и уменьшить риски ошибок на следующих шагах. Мы хотим получить воспроизводимый артефакт (конфиг/скрипт/отчёт), который ясно отвечает на вопрос «зачем это делаем» и позволяет проверить результат без ручной интерпретации. Метод выполнения: фиксируем входы, определяем критерий готовности, делаем проверяемый выход и логируем. Ожидаемый эффект — сокращение времени на повторные итерации и возможность масштабировать подход на новые участки.",
          "description": "Add a runway calculator that estimates remaining days given a treasury size and configured daily caps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "20.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 20 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Houseparty: волна хайпа не превратилась в устойчивый ритуал и продукт угас. Мы должны анализировать не только школы/волны, которые взлетели, но и те, что не дали эффекта. Нужна карта «failed waves»: какие окна, какие квесты, какой seed‑level. Сравниваем их с успешными волнами, корректируем расписание, плотность seed‑создателей, тип наград и ритуалов. Итог: стратегия запуска усиливается за счёт анализа провалов, и риск одноразового всплеска минимизируется. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "21",
      "status": "pending",
      "notes": "Standalone reporting module; can read from rollups only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Create a daily budget report generator that outputs per-school spend (PJM and USD) and remaining budget for the day.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "21.1",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement a report builder that joins rollups with budget config to compute spent_pjm, spent_usd, remaining_pjm, and remaining_usd.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "21.2",
          "status": "pending",
          "notes": "Output-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a serializer that writes the report as JSON (e.g., reports/budget_daily_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "21.3",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 21 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "22",
      "status": "pending",
      "notes": "Standalone geo module to drive local network effects. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement geo-cell indexing and local feed ranking to surface nearby streams with a micro-local bias.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "22.1",
          "status": "pending",
          "notes": "Data model only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Define a GeoCell model (cell_id, lat, lng, radius_m) and attach it to stream metadata.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "22.2",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement a cell-mapping function that buckets a stream into the nearest GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "22.3",
          "status": "pending",
          "notes": "Query-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a local feed query that returns streams ordered by proximity and recency within a GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "22.4",
          "status": "pending",
          "notes": "Unit-testable. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add tests for cell mapping and proximity ranking with edge-case coordinates.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "22.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 22 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "23",
      "status": "pending",
      "notes": "Standalone growth feature; no dependency on other tasks. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement local invite tokens (QR/deep link) that attribute new users to a GeoCell or school group.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "23.1",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Create an invite token generator that encodes inviter_id, geo_cell_id, and expiration.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "23.2",
          "status": "pending",
          "notes": "Server-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a token validation endpoint that returns attribution metadata for signup/join flows.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "23.3",
          "status": "pending",
          "notes": "Local storage only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Persist invite attribution on device and attach it to the first quest completion event.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "23.4",
          "status": "pending",
          "notes": "Anti-abuse guard. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add rate limits on invite generation and validation per user/day.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "23.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 23 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "24",
      "status": "pending",
      "notes": "Standalone interaction module; can be implemented without rewards. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement a lightweight real-time challenge system where viewers issue micro-quests and streamers accept/complete them.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "24.1",
          "status": "pending",
          "notes": "Schema only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Define a Challenge model with fields: id, stream_id, issuer_id, text, status, created_at, expires_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "24.2",
          "status": "pending",
          "notes": "Server-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add endpoints to create, accept, and complete challenges with basic authorization.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "24.3",
          "status": "pending",
          "notes": "Client-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a challenge queue UI for streamers to accept/complete a challenge within a time window.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "24.4",
          "status": "pending",
          "notes": "Anti-abuse. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add per-viewer rate limits and a profanity/safety filter for challenge text.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "25",
      "status": "pending",
      "notes": "Standalone economy module; can be used with or without crypto transfer. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement an internal reward wallet with locked/unlocked balances and delayed unlock rules.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "25.1",
          "status": "pending",
          "notes": "Schema only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Define WalletBalance with fields: user_id, available_pjm, locked_pjm, updated_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "25.2",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement applyReward(user_id, pjm_amount, locked_ratio) that splits rewards into available and locked amounts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "25.3",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement unlockRules that release locked PJM after N quest completions or N active days.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "25.4",
          "status": "pending",
          "notes": "Simple API. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a balance endpoint or helper that returns available and locked PJM for the client UI.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "26",
      "status": "pending",
      "notes": "Standalone safety module; deterministic rules only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement a safety rules engine that flags streams and challenges based on configurable policy rules.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "26.1",
          "status": "pending",
          "notes": "Config only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Create a safety rules config file with denylisted words, max message length, and quiet-hours rules.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "26.2",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement a rules evaluator that returns flags and enforcement actions (warn, hide, throttle).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "26.3",
          "status": "pending",
          "notes": "Server-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add an enforcement hook that applies actions to streams/challenges based on rule flags.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "26.4",
          "status": "pending",
          "notes": "Audit trail only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Persist rule hits and enforcement actions in a safety audit log.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "26.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 26 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "27",
      "status": "pending",
      "notes": "Standalone analytics; reads from events only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Add geo-scale health metrics: supply/demand ratio per GeoCell and creator retention by cell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "27.1",
          "status": "pending",
          "notes": "Schema only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Define a GeoCellDailyMetrics record with fields: cell_id, date, streams_started, viewers, quests_completed.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "27.2",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement daily aggregation for supply/demand ratio (streams_started vs viewers) per GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "27.3",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Compute creator retention by GeoCell (D1/D7) using quest completion events.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "27.4",
          "status": "pending",
          "notes": "Output-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a JSON report generator for geo-scale metrics (e.g., reports/geo_metrics_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "27.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 27 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "28",
      "status": "completed",
      "notes": "Standalone product strategy tooling; config + visualization. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement a Strategy Canvas tool that renders value curves for Pyjam vs competitors from a local config file.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "28.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Create a strategy_canvas.json file with factors (geo, interactivity, monetization, safety, entry_barrier, content_realness) and per-product scores.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "28.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "28.2",
          "status": "completed",
          "notes": "UI-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Build a small chart renderer (SVG/Canvas) that visualizes value curves from the config.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "28.2.1",
              "status": "pending",
              "notes": "",
              "description": "Довести анализ до исследовательного уровня: заменить предположения на реальные источники (конкуренты, интервью, метрики), зафиксировать ссылки/доказательства, пересчитать оценки и сохранить версионированный результат для сравнения во времени.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "28.3",
          "status": "completed",
          "notes": "Output-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add an export-to-JSON snapshot for tracked changes in value curves over time.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "28.3.1",
              "status": "pending",
              "notes": "",
              "description": "Довести анализ до исследовательного уровня: заменить предположения на реальные источники (конкуренты, интервью, метрики), зафиксировать ссылки/доказательства, пересчитать оценки и сохранить версионированный результат для сравнения во времени.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "28.4",
          "status": "pending",
          "notes": "",
          "description": "Довести анализ до исследовательного уровня: заменить предположения на реальные источники (конкуренты, интервью, метрики), зафиксировать ссылки/доказательства, пересчитать оценки и сохранить версионированный результат для сравнения во времени.",
          "subtasks": []
        },
        {
          "number": "28.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 28 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "29",
      "status": "pending",
      "notes": "Standalone config + validation; no runtime dependency. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement an ERRC (Eliminate-Reduce-Raise-Create) grid config and a linter that checks new feature flags against the grid.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "29.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Create errc_grid.json with arrays for eliminate, reduce, raise, create factors.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "29.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "29.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a linter script that reads feature flags and ensures each new flag maps to a grid factor.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "29.2.1",
              "status": "pending",
              "notes": "",
              "description": "Довести контроль до рабочего уровня: добавить edge‑cases, убедиться, что правила покрывают все ключевые случаи, подготовить sample‑данные для проверки и включить этот контроль в рабочий пайплайн.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "29.3",
          "status": "pending",
          "notes": "CI-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Wire the linter into CI to fail when a feature change is not aligned to the grid.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "29.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 29 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — IRL: метрики были искусственно завышены, продукт потерял доверие и закрылся. В нашем плане нужно изучать не только измеряемые события, но и «невидимые» — пользователей без событий, расхождения GA4 и внутренних логов, пустые стримы. Создаётся отдельный отчёт survivorship‑bias по метрикам: какие события отсутствуют и как это влияет на выводы. Итог: метрики становятся достоверными, а решения принимаются на полной картине, а не только на «выживших» данных. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "30",
      "status": "pending",
      "notes": "Standalone onboarding module; no dependency on rewards. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
      "description": "Implement a zero-friction 'Go Live in 1 Tap' entry that bypasses setup and starts a 60-second stream instantly.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "30.1",
          "status": "pending",
          "notes": "UI-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Add a QuickStart button on the map screen that launches the stream immediately with defaults.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "30.2",
          "status": "pending",
          "notes": "Client-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Implement default stream settings (no title, no category) and auto-start the camera.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "30.3",
          "status": "pending",
          "notes": "Analytics-only. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций. Этот пункт нужен, чтобы зафиксировать управляемую логику выполнения и обеспечить предсказуемый результат. Мы достигаем этого через чёткие входы, проверяемые шаги и измеримый выход (файл/отчёт/метрика). Метод: описываем, какие данные требуются, какие преобразования делаются, как фиксируются ошибки, и что является критериями завершения. Результат должен быть пригоден для последующей интеграции и аудита, чтобы избежать ручных импровизаций.",
          "description": "Track conversion from map view to first live stream for QuickStart vs standard flow.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "31",
      "status": "pending",
      "notes": "Standalone loop orchestrator; can run with mocks. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a Klaus-loop orchestrator that guarantees the first quest, instant reward UI, and Glow Pin for first-time streamers.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "31.1",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add an orchestrator that triggers: quest_assigned -> quest_completed -> reward_granted -> glow_applied.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "31.2",
          "status": "pending",
          "notes": "Client-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Integrate the orchestrator with the stream UI using a local mock reward source.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "31.3",
          "status": "pending",
          "notes": "Analytics-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Emit a single composite event that captures the full loop completion for funnel analysis.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "32",
      "status": "pending",
      "notes": "Standalone noncustomer conversion module. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a viewer-to-creator conversion flow that prompts passive viewers to try a 60-second stream with a safe quest.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "32.1",
          "status": "pending",
          "notes": "UI-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add a modal or inline prompt that appears after a viewer watches N seconds of a nearby stream.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "32.2",
          "status": "pending",
          "notes": "Client-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Preload a safe quest and show a one-tap action to start streaming immediately.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "32.3",
          "status": "pending",
          "notes": "Analytics-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Track conversion from viewer to creator for the prompt flow.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "32.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 32 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "33",
      "status": "pending",
      "notes": "Standalone reward tapering; pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a reward tapering engine that gradually shifts incentives from PJM to visibility/status as a creator becomes active.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "33.1",
          "status": "pending",
          "notes": "Config only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Create reward_tapering.json with tiers (new, warm, habitual) and payout multipliers per tier.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "33.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Implement a tier resolver that assigns a creator to a tier based on completed quests and active days.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "33.3",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Apply tapering to PJM payouts and substitute with Glow/Boost flags when payout is reduced.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "34",
      "status": "pending",
      "notes": "Standalone local fame layer; UI + aggregation. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a local fame leaderboard and map overlays that highlight top creators per school/GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "34.1",
          "status": "pending",
          "notes": "Schema only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Define LocalFameScore with fields: user_id, cell_id, score, date, rank.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "34.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Implement daily scoring rules for local fame (quests completed, streak milestones, viewer interactions).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "34.3",
          "status": "pending",
          "notes": "UI-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add a map overlay for Top-3 local creators with visible badges and pin styles.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "34.4",
          "status": "pending",
          "notes": "Output-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add a JSON leaderboard endpoint or report for local fame rankings.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "34.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 34 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "35",
      "status": "pending",
      "notes": "Standalone safety template module; no AI dependency. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a safe challenge template library for avatar tasks with allowlist tags and automatic rejection of unsafe prompts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "35.1",
          "status": "pending",
          "notes": "Config only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Create safe_challenge_templates.json with template ids, text, safe_tags, and age_rating.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "35.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Implement a validator that rejects challenges not matching allowlisted tags or exceeding max length.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "35.3",
          "status": "pending",
          "notes": "Server-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add an endpoint to serve safe templates and fallback to templates when user input is blocked.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "35.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 35 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "36",
      "status": "pending",
      "notes": "Standalone ritual scheduler; config-driven. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.\n\nПочему такой выбор: off‑campus+after‑school минимизирует барьеры согласований и юридические риски, оставляя эффект «рядом со школой»; private‑first даёт быстрые договорённости и символический престиж, который запускает эффект подражания; co‑ed фокус ускоряет «склейку» сетей и снижает фрагментацию аудитории. Публичные школы подключаем во 2‑й волне, когда есть доказанный эффект и кейсы для администраций.",
      "description": "Implement a daily ritual calendar that assigns a themed local challenge window per GeoCell (e.g., after-school theme).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений.\n\nРЕШЕНИЕ ДЛЯ ПИЛОТА (принято здесь и дальше используется как норматив): (1) запуск ТОЛЬКО после уроков и ВНЕ территории школы — off-campus geofence 300–600м вокруг кампуса; on-campus допускается только при отдельном письменном разрешении/партнёрстве; (2) тип школ для старта: private‑first (быстрее согласования и сильнее символический статус), public — волна 2 после подтверждения метрик; (3) аудитория: co‑ed по умолчанию (максимальная сеть и межклассные эффекты), а для single‑sex школ применяются те же механики, но с адаптированными квестами/креативами. Эти параметры должны быть закодированы в конфигах и проверяться в рантайме.",
      "subtasks": [
        {
          "number": "36.1",
          "status": "pending",
          "notes": "Config only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Create ritual_calendar.json with per-day themes, start/end times, and eligible GeoCells.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "36.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Implement a scheduler that returns the active ritual theme for a given GeoCell and time.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "36.3",
          "status": "pending",
          "notes": "UI-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Expose the active ritual theme as a map banner and filter for relevant quests.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "36.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 36 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "37",
      "status": "pending",
      "notes": "Standalone strategy guard; CI-integrated. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement a Strategic Sequence checker (utility → price → cost → adoption) as a config + linter for new features.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "37.1",
          "status": "completed",
          "notes": "Config only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Create strategic_sequence.json defining required checks and thresholds per feature type.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "37.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "37.2",
          "status": "completed",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add a linter that validates each feature flag entry includes utility, price impact, cost impact, and adoption risk tags.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "37.2.1",
              "status": "pending",
              "notes": "",
              "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "37.3",
          "status": "pending",
          "notes": "CI-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Wire the sequence checker into CI to block changes missing strategic sequence metadata.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "37.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 37 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "38",
      "status": "pending",
      "notes": "Standalone noncustomer analytics. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement noncustomer tier tagging (soon-to-be, refusing, unexplored) and track conversion into creators.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "38.1",
          "status": "pending",
          "notes": "Schema only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Define NoncustomerTag with fields: user_id, tier, tagged_at, reason_code.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "38.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add tagging rules based on engagement signals (views only, no quests, no streams).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "38.3",
          "status": "pending",
          "notes": "Analytics-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Track conversion from each tier into first stream and first quest completion.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "38.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 38 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — IRL: метрики были искусственно завышены, продукт потерял доверие и закрылся. В нашем плане нужно изучать не только измеряемые события, но и «невидимые» — пользователей без событий, расхождения GA4 и внутренних логов, пустые стримы. Создаётся отдельный отчёт survivorship‑bias по метрикам: какие события отсутствуют и как это влияет на выводы. Итог: метрики становятся достоверными, а решения принимаются на полной картине, а не только на «выживших» данных. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "39",
      "status": "pending",
      "notes": "Standalone trust loop safeguards; deterministic rules. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement anti-bullying throttles for repeated negative interactions within a GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "39.1",
          "status": "pending",
          "notes": "Schema only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Define InteractionFlag with fields: user_id, target_id, flag_type, count, last_seen_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "39.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Add throttling rules that reduce interaction privileges after repeated flags in a short window.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "39.3",
          "status": "pending",
          "notes": "Server-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Enforce throttles on challenge creation and commenting within the affected GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "39.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 39 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "40",
      "status": "pending",
      "notes": "Standalone growth analytics; event-driven. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
      "description": "Implement an AARRR funnel pipeline that computes acquisition, activation, retention, referral, and revenue metrics per GeoCell and school.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "40.1",
          "status": "pending",
          "notes": "Schema only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Define a FunnelEvent schema with fields: user_id, event_type, cell_id, school_id, created_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "40.2",
          "status": "pending",
          "notes": "Pure logic. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Implement daily aggregation functions for AARRR stages based on event_type mappings.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "40.3",
          "status": "pending",
          "notes": "Output-only. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок. Этот шаг нужен, чтобы обеспечить контроль качества и управляемость процесса. Мы хотим получить понятный артефакт и измеримый результат, который снижает неопределённость. Способ достижения: фиксируем входные данные, выполняем преобразование по правилам, валидируем выход и сохраняем лог/отчёт. Итогом должен быть результат, который можно использовать дальше без дополнительных ручных проверок.",
          "description": "Generate JSON funnel reports per GeoCell (e.g., reports/funnel_<date>_<cell>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "40.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 40 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "41",
      "status": "pending",
      "notes": "Standalone retention analytics; pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement cohort retention calculator (D1/D3/D7/D14) for creators and viewers.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "41.1",
          "status": "pending",
          "notes": "Schema only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Define CohortKey with fields: cohort_date, user_id, role_type (viewer|creator).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "41.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add a retention calculator that outputs cohort tables for D1/D3/D7/D14.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "41.3",
          "status": "pending",
          "notes": "Output-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Write cohort tables to JSON (e.g., reports/cohorts_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "41.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 41 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "42",
      "status": "pending",
      "notes": "Standalone referral analytics; no dependency on rewards. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement k-factor computation and viral loop diagnostics using invite attribution events.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "42.1",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Compute k-factor as (invites sent × invite conversion rate) per GeoCell and school.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "42.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add loop diagnostics: time-to-invite, time-to-first-quest for invited users.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "42.3",
          "status": "pending",
          "notes": "Output-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Generate a daily viral report JSON with k-factor and loop timings.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "42.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 42 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — IRL: метрики были искусственно завышены, продукт потерял доверие и закрылся. В нашем плане нужно изучать не только измеряемые события, но и «невидимые» — пользователей без событий, расхождения GA4 и внутренних логов, пустые стримы. Создаётся отдельный отчёт survivorship‑bias по метрикам: какие события отсутствуют и как это влияет на выводы. Итог: метрики становятся достоверными, а решения принимаются на полной картине, а не только на «выживших» данных. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "43",
      "status": "pending",
      "notes": "Standalone activation module; client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement a first-action activation prompt that fires after map view with a single-tap 'Start 60s quest' CTA.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "43.1",
          "status": "pending",
          "notes": "UI-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add a lightweight activation prompt banner on the map with one primary action.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "43.2",
          "status": "pending",
          "notes": "Client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Hook the banner to the Starter Quest flow to launch immediately.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "43.3",
          "status": "pending",
          "notes": "Analytics-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Track activation prompt impressions, clicks, and quest start rate.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "43.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 43 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "44",
      "status": "pending",
      "notes": "Standalone revenue analytics; config-driven. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement revenue attribution for PJM rewards and compute ARPU/LTV proxies per cohort.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "44.1",
          "status": "pending",
          "notes": "Schema only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Define RevenueEvent with fields: user_id, event_type, pjm_amount, usd_equivalent, created_at.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "44.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Compute ARPU and LTV proxies per cohort using RevenueEvent and retention tables.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "44.3",
          "status": "pending",
          "notes": "Output-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Generate daily revenue proxy reports in JSON (e.g., reports/revenue_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "44.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 44 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "45",
      "status": "pending",
      "notes": "Standalone growth-loop mapping; event-driven. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement a growth-loop mapper that assigns events to UGC, Viewer, and Social loops and computes loop health metrics.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "45.1",
          "status": "pending",
          "notes": "Config only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Create growth_loops.json mapping event types to loop stages (ugc_create, ugc_discover, viewer_watch, viewer_engage, social_invite, social_join).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "45.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Implement a loop aggregator that computes cycle completion rate and average time per loop.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "45.3",
          "status": "pending",
          "notes": "Output-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Generate daily loop health reports (e.g., reports/loops_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "45.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 45 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "46",
      "status": "pending",
      "notes": "Standalone reward variability engine; pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement a variable reward scheduler that selects reward types within bounded ranges to support habit formation without overspending.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "46.1",
          "status": "pending",
          "notes": "Config only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Create variable_rewards.json defining reward bundles (pjm_range, glow_duration_sec, badge_variant) and probabilities.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "46.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Implement a scheduler that selects a bundle per completion and enforces per-user daily caps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "46.3",
          "status": "pending",
          "notes": "Self-contained tests. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add tests to verify probability weights, cap enforcement, and deterministic output with a seed.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "46.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 46 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "47",
      "status": "pending",
      "notes": "Standalone ethics guard; client + config. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement notification budgets and quiet hours to prevent over-pressuring users.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "47.1",
          "status": "pending",
          "notes": "Config only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Create notification_policy.json with max_per_day, quiet_hours, and priority tiers.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "47.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Implement a notification budgeter that blocks or defers sends when limits are reached.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "47.3",
          "status": "pending",
          "notes": "Client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add user controls to mute categories and set personal quiet hours.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "47.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 47 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "48",
      "status": "pending",
      "notes": "Standalone experimentation framework; no dependency on other tasks. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement an A/B testing framework for reward amounts, glow duration, and quest types with assignment and exposure logging.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "48.1",
          "status": "pending",
          "notes": "Config only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Create experiments.json defining experiment ids, variants, and rollout percentages.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "48.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Implement deterministic user assignment using user_id hashing and variant weights.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "48.3",
          "status": "pending",
          "notes": "Analytics-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Log experiment exposures and variant outcomes to the event pipeline.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "49",
      "status": "pending",
      "notes": "Standalone referral asset generator; client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement a shareable local achievement card that embeds an invite link and GeoCell attribution.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "49.1",
          "status": "pending",
          "notes": "Client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Extend the share-card generator to include a QR code or deep link token tied to a GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "49.2",
          "status": "pending",
          "notes": "Client-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Add a card variant for streak milestones and local fame ranks.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "49.3",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 49 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "50",
      "status": "pending",
      "notes": "Standalone analytics; detects overjustification risk. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
      "description": "Implement an incentive-dependence monitor that tracks the ratio of reward-driven actions vs organic actions per user cohort.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "50.1",
          "status": "pending",
          "notes": "Schema only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Define IncentiveDependencyMetric with fields: cohort_date, reward_actions, organic_actions, ratio.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "50.2",
          "status": "pending",
          "notes": "Pure logic. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Compute daily ratios for new/warm/habitual tiers and flag high-dependence cohorts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "50.3",
          "status": "pending",
          "notes": "Output-only. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита. Зачем это нужно: пункт создаёт проверяемый шаг, который снижает неопределённость и даёт стабильный результат. Мы хотим добиться понятной связи «вход → обработка → выход», чтобы можно было повторять процесс и масштабировать его. Подход: зафиксировать требования к данным, выполнить преобразование по правилам, и обеспечить отчётность. Результат — артефакт (скрипт/отчёт/конфиг), который можно использовать как опору для следующих задач и аудита.",
          "description": "Generate a daily incentive-dependence report JSON (e.g., reports/incentive_dependency_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "50.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 50 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — IRL: метрики были искусственно завышены, продукт потерял доверие и закрылся. В нашем плане нужно изучать не только измеряемые события, но и «невидимые» — пользователей без событий, расхождения GA4 и внутренних логов, пустые стримы. Создаётся отдельный отчёт survivorship‑bias по метрикам: какие события отсутствуют и как это влияет на выводы. Итог: метрики становятся достоверными, а решения принимаются на полной картине, а не только на «выживших» данных. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "51",
      "status": "pending",
      "notes": "Standalone starter bonus engine; server or client mock. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a first-quest starter bonus rule that awards PJM instantly on the first completed quest per day.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "51.1",
          "status": "pending",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create starter_bonus.json with fields: pjm_amount, max_per_day, cooldown_hours.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "51.2",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Implement a starter bonus validator that checks daily eligibility and returns awardable amount.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "51.3",
          "status": "pending",
          "notes": "Event-driven. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Emit a starter_bonus_awarded event on quest completion for analytics and budgeting.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "52",
      "status": "pending",
      "notes": "Standalone auto-quest bootstrap; no viewer dependency. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement an auto-quest bootstrapper that assigns a safe quest when a stream starts and no viewers are present.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "52.1",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Add a check that assigns a safe quest within the first N seconds of a new stream if viewer_count == 0.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "52.2",
          "status": "pending",
          "notes": "Client-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Display the auto-assigned quest in the stream overlay with a one-tap Done action.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "52.3",
          "status": "pending",
          "notes": "Analytics-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Track auto-quest assignment rate and completion rate.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "52.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 52 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "53",
      "status": "pending",
      "notes": "Standalone map visibility booster. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a first-quest map boost that highlights new streamers for a short window after completion.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "53.1",
          "status": "pending",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create map_boost.json with fields: boost_duration_sec, boost_style_variant, eligible_event_types.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "53.2",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Trigger a Glow Pin or Boost flag when a first-quest completion event is received.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "53.3",
          "status": "pending",
          "notes": "Analytics-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Track boost impressions and downstream viewer joins.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "53.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 53 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "54",
      "status": "pending",
      "notes": "Standalone pilot harness; config-driven. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.\n\nПочему такой выбор: off‑campus+after‑school минимизирует барьеры согласований и юридические риски, оставляя эффект «рядом со школой»; private‑first даёт быстрые договорённости и символический престиж, который запускает эффект подражания; co‑ed фокус ускоряет «склейку» сетей и снижает фрагментацию аудитории. Публичные школы подключаем во 2‑й волне, когда есть доказанный эффект и кейсы для администраций.",
      "description": "Implement a school pilot gate that enables the starter bonus + auto-quest + boost only for selected GeoCells.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений.\n\nРЕШЕНИЕ ДЛЯ ПИЛОТА (принято здесь и дальше используется как норматив): (1) запуск ТОЛЬКО после уроков и ВНЕ территории школы — off-campus geofence 300–600м вокруг кампуса; on-campus допускается только при отдельном письменном разрешении/партнёрстве; (2) тип школ для старта: private‑first (быстрее согласования и сильнее символический статус), public — волна 2 после подтверждения метрик; (3) аудитория: co‑ed по умолчанию (максимальная сеть и межклассные эффекты), а для single‑sex школ применяются те же механики, но с адаптированными квестами/креативами. Эти параметры должны быть закодированы в конфигах и проверяться в рантайме.",
      "subtasks": [
        {
          "number": "54.1",
          "status": "pending",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create pilot_geo_cells.json listing enabled GeoCells and rollout percentages.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "54.2",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Add a feature gate that checks GeoCell eligibility before applying starter bonus or auto-quest.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "54.3",
          "status": "pending",
          "notes": "Analytics-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Tag pilot events with geo_cell_id and rollout group for A/B evaluation.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "54.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 54 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "55",
      "status": "pending",
      "notes": "Standalone viral add-on; client-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a Fan Quest Chain prompt that appears after the first quest and encourages sharing for an extra visibility boost.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "55.1",
          "status": "pending",
          "notes": "UI-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Add a post-quest modal with one-tap share CTA and a preview of the extra boost reward.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "55.2",
          "status": "pending",
          "notes": "Client-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Implement a share action that attaches the user's GeoCell invite token to the share card/link.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "55.3",
          "status": "pending",
          "notes": "Analytics-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Track share attempts, successful shares, and downstream joins attributed to the Fan Quest Chain.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "55.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 55 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "56",
      "status": "pending",
      "notes": "Standalone A/B variants for the starter hack. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Add experiment variants that compare PJM vs Glow-only and solo vs school-duel modes for the first-quest flow.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "56.1",
          "status": "pending",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Extend experiments.json with variants: starter_pjm_vs_glow and starter_solo_vs_duel.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "56.2",
          "status": "pending",
          "notes": "Client-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Wire UI variants to show PJM reward vs Glow-only and solo vs school-duel banners.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "56.3",
          "status": "pending",
          "notes": "Analytics-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Log variant outcomes for activation, D1 creator retention, and streams per 1k users.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "56.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 56 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Houseparty: волна хайпа не превратилась в устойчивый ритуал и продукт угас. Мы должны анализировать не только школы/волны, которые взлетели, но и те, что не дали эффекта. Нужна карта «failed waves»: какие окна, какие квесты, какой seed‑level. Сравниваем их с успешными волнами, корректируем расписание, плотность seed‑создателей, тип наград и ритуалов. Итог: стратегия запуска усиливается за счёт анализа провалов, и риск одноразового всплеска минимизируется. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "57",
      "status": "pending",
      "notes": "Standalone metric pack; output-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a starter-hack KPI report covering first-stream rate, D1 creator retention, streams per 1k users, and boosted-to-organic ratio.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "57.1",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Compute first-stream rate within 24 hours of signup per GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "57.2",
          "status": "pending",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Compute boosted-to-organic ratio: % of boosted streams that later occur without auto-quest or boost.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "57.3",
          "status": "pending",
          "notes": "Output-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Generate JSON report (e.g., reports/starter_hack_kpis_<date>.json).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "57.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 57 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "58",
      "status": "completed",
      "notes": "Standalone Blue Ocean analytics; config + scoring. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a Buyer Utility Map tool (buyer experience cycle × utility levers) with scoring and gap detection.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "58.1",
          "status": "completed",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create buyer_utility_map.json defining experience stages (purchase, delivery, use, supplements, maintenance, disposal) and utility levers (productivity, simplicity, convenience, risk, fun, environmental).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "58.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "58.2",
          "status": "completed",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Implement a scoring engine that assigns 1–5 scores per cell and detects low-scoring gaps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "58.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "58.3",
          "status": "completed",
          "notes": "Output-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Generate a JSON gap report highlighting top 5 utility opportunities.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "58.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "58.4",
          "status": "pending",
          "notes": "",
          "description": "Довести анализ до исследовательного уровня: заменить предположения на реальные источники (конкуренты, интервью, метрики), зафиксировать ссылки/доказательства, пересчитать оценки и сохранить версионированный результат для сравнения во времени.",
          "subtasks": []
        },
        {
          "number": "58.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 58 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "59",
      "status": "completed",
      "notes": "Standalone pricing tool; config + calculator. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a Price Corridor of the Mass calculator that recommends a strategic price range based on alternatives and substitutes.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "59.1",
          "status": "completed",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create price_corridor.json with competitor/alternative prices, tiers (low/mid/high), and buyer segments.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "59.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "59.2",
          "status": "completed",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Compute corridor bounds and recommend a strategic price point within the mass corridor.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "59.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "59.3",
          "status": "completed",
          "notes": "Output-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Generate a pricing recommendation report JSON with corridor bounds and rationale fields.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "59.3.1",
              "status": "pending",
              "notes": "",
              "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "59.4",
          "status": "pending",
          "notes": "",
          "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
          "subtasks": []
        },
        {
          "number": "59.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 59 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "60",
      "status": "completed",
      "notes": "Standalone cost tool; config + calculator. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
      "description": "Implement a Target Costing calculator that derives target cost from strategic price and required margin.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "60.1",
          "status": "completed",
          "notes": "Config only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Create target_costing.json with strategic_price, margin_target, and cost_components.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "60.1.1",
              "status": "pending",
              "notes": "",
              "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "60.2",
          "status": "completed",
          "notes": "Pure logic. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Compute target_cost and allowable per-component budgets.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "60.2.1",
              "status": "pending",
              "notes": "",
              "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "60.3",
          "status": "completed",
          "notes": "Output-only. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа. Пояснение: этот пункт нужен, чтобы закрепить способ выполнения и сделать результат прозрачным для команды. Мы достигаем этого через явные входы, пошаговую обработку и проверяемый выход, который можно сверить. Такой подход минимизирует ручные ошибки и позволяет опираться на единый стандарт. Ожидаемый результат — воспроизводимый артефакт, пригодный для масштабирования и последующего анализа.",
          "description": "Generate a target-cost report JSON with component budgets and gap-to-current-cost fields.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "60.3.1",
              "status": "pending",
              "notes": "",
              "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "60.4",
          "status": "pending",
          "notes": "",
          "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
          "subtasks": []
        },
        {
          "number": "60.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 60 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "61",
      "status": "pending",
      "notes": "Standalone adoption risk tooling; config + linter. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement an Adoption Hurdles checklist (cognitive, resource, motivational, political) and require each feature to declare mitigations.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "61.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create adoption_hurdles.json with required mitigation fields per hurdle type.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "61.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "61.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Add a linter that validates feature flags include mitigations for each hurdle type.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "61.2.1",
              "status": "pending",
              "notes": "",
              "description": "Довести контроль до рабочего уровня: добавить edge‑cases, убедиться, что правила покрывают все ключевые случаи, подготовить sample‑данные для проверки и включить этот контроль в рабочий пайплайн.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "61.3",
          "status": "pending",
          "notes": "CI-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Wire the adoption-hurdle linter into CI to block features without mitigation metadata.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "62",
      "status": "completed",
      "notes": "Standalone value innovation scoring; analytics-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement a Value Innovation Index that combines buyer utility gains, cost reductions, and differentiation signals.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "62.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create value_innovation_index.json defining weights for utility, cost, differentiation, and adoption friction.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "62.1.1",
              "status": "pending",
              "notes": "",
              "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "62.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Compute a composite score per feature or release from existing reports (utility gaps, cost targets, strategy canvas).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "62.2.1",
              "status": "pending",
              "notes": "",
              "description": "Довести анализ до исследовательного уровня: заменить предположения на реальные источники (конкуренты, интервью, метрики), зафиксировать ссылки/доказательства, пересчитать оценки и сохранить версионированный результат для сравнения во времени.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "62.3",
          "status": "completed",
          "notes": "Output-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Generate a value-innovation report JSON with ranked features and score deltas.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "62.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "62.4",
          "status": "pending",
          "notes": "",
          "description": "Довести анализ до исследовательного уровня: заменить предположения на реальные источники (конкуренты, интервью, метрики), зафиксировать ссылки/доказательства, пересчитать оценки и сохранить версионированный результат для сравнения во времени.",
          "subtasks": []
        },
        {
          "number": "62.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 62 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "63",
      "status": "completed",
      "notes": "Standalone differentiation guard; analytics-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement Strategy Canvas diagnostics to enforce focus, divergence, and a compelling tagline signal.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "63.1",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Compute focus and divergence scores from the strategy_canvas.json curves.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "63.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "63.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Add a tagline-fit checker that ensures at least one concise value statement can be derived from top curve peaks.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "63.2.1",
              "status": "pending",
              "notes": "",
              "description": "Довести контроль до рабочего уровня: добавить edge‑cases, убедиться, что правила покрывают все ключевые случаи, подготовить sample‑данные для проверки и включить этот контроль в рабочий пайплайн.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "63.3",
          "status": "completed",
          "notes": "Output-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Generate a differentiation report JSON with focus/divergence scores and tagline candidates.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "63.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "63.4",
          "status": "pending",
          "notes": "",
          "description": "Довести анализ до исследовательного уровня: заменить предположения на реальные источники (конкуренты, интервью, метрики), зафиксировать ссылки/доказательства, пересчитать оценки и сохранить версионированный результат для сравнения во времени.",
          "subtasks": []
        },
        {
          "number": "63.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 63 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "64",
      "status": "completed",
      "notes": "Bind reports to real analytics sources (GA4). Do not hardcode secrets; use env vars. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Add analytics source configuration for GA4 (account 372664399, property 510154368) and a fetcher that stores raw metrics for report pipelines.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "64.1",
          "status": "completed",
          "notes": "Config only; no secrets committed. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create config/analytics_sources.json with GA4 account/property IDs and required env vars (GA_ACCESS_TOKEN, GA_PROJECT_ID).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "64.1.1",
              "status": "pending",
              "notes": "",
              "description": "Доработать завершённую задачу до боевого уровня: проверить подключение к реальным источникам (GA4/внутренние события), сверить схему и event mapping, прогнать на реальных данных за 1–2 дня, зафиксировать расхождения, добавить базовые проверки и автоматизацию запуска.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "64.2",
          "status": "completed",
          "notes": "Script-only; uses GA Data API. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement scripts/fetch_ga4_metrics.py to pull daily totals (users, sessions, eventCount) into reports/raw/ga4_<date>.json.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "64.2.1",
              "status": "pending",
              "notes": "",
              "description": "Доработать завершённую задачу до боевого уровня: проверить подключение к реальным источникам (GA4/внутренние события), сверить схему и event mapping, прогнать на реальных данных за 1–2 дня, зафиксировать расхождения, добавить базовые проверки и автоматизацию запуска.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "64.3",
          "status": "completed",
          "notes": "Mapping only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create config/event_mapping.json to map GA4 events to internal events used by AARRR and loop reports.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "64.3.1",
              "status": "pending",
              "notes": "",
              "description": "Доработать завершённую задачу до боевого уровня: проверить подключение к реальным источникам (GA4/внутренние события), сверить схему и event mapping, прогнать на реальных данных за 1–2 дня, зафиксировать расхождения, добавить базовые проверки и автоматизацию запуска.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "64.4",
          "status": "pending",
          "notes": "",
          "description": "Доработать завершённую задачу до боевого уровня: проверить подключение к реальным источникам (GA4/внутренние события), сверить схему и event mapping, прогнать на реальных данных за 1–2 дня, зафиксировать расхождения, добавить базовые проверки и автоматизацию запуска.",
          "subtasks": []
        },
        {
          "number": "64.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 64 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — IRL: метрики были искусственно завышены, продукт потерял доверие и закрылся. В нашем плане нужно изучать не только измеряемые события, но и «невидимые» — пользователей без событий, расхождения GA4 и внутренних логов, пустые стримы. Создаётся отдельный отчёт survivorship‑bias по метрикам: какие события отсутствуют и как это влияет на выводы. Итог: метрики становятся достоверными, а решения принимаются на полной картине, а не только на «выживших» данных. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "65",
      "status": "pending",
      "notes": "Report adapter layer; reads raw GA4 data and internal event logs. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Update report generators to consume real GA4 metrics + internal event mappings and persist normalized metrics for dashboards.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "65.1",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement a normalization step that converts GA4 raw metrics into internal daily metrics (dau, wau, mau, activation_rate).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "65.2",
          "status": "pending",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Wire AARRR, cohort, and loop reports to read from normalized metrics plus event_mapping.json.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "65.3",
          "status": "pending",
          "notes": "Output-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Write normalized metrics to reports/normalized_metrics_<date>.json for dashboard consumption.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "65.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 65 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "66",
      "status": "completed",
      "notes": "Dashboard generation; JSON + SVG outputs. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Generate a one-page Blue Ocean dashboard (JSON + SVG) that aggregates strategy canvas, buyer utility gaps, AARRR, and loop health metrics.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "66.1",
          "status": "completed",
          "notes": "Schema only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Define dashboard schema (cards: value_curve, utility_gaps, aarr, loops, budget, local_fame).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "66.1.1",
              "status": "pending",
              "notes": "",
              "description": "Доработать завершённую задачу до боевого уровня: проверить подключение к реальным источникам (GA4/внутренние события), сверить схему и event mapping, прогнать на реальных данных за 1–2 дня, зафиксировать расхождения, добавить базовые проверки и автоматизацию запуска.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "66.2",
          "status": "completed",
          "notes": "Script-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement scripts/build_blue_ocean_dashboard.py to read reports/*.json and output reports/blue_ocean_dashboard.json.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "66.2.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "66.3",
          "status": "completed",
          "notes": "SVG-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement an SVG renderer that produces reports/blue_ocean_dashboard.svg from the dashboard JSON.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "66.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "66.4",
          "status": "pending",
          "notes": "",
          "description": "Доработать завершённую задачу до боевого уровня: проверить подключение к реальным источникам (GA4/внутренние события), сверить схему и event mapping, прогнать на реальных данных за 1–2 дня, зафиксировать расхождения, добавить базовые проверки и автоматизацию запуска.",
          "subtasks": []
        },
        {
          "number": "66.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 66 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "67",
      "status": "completed",
      "notes": "Standalone model to estimate chain-reaction thresholds (Jasper loop). Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement a viral chain reaction simulator that estimates required seed creators per GeoCell to reach a target stream volume within a time window.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "67.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create viral_model_inputs.json with parameters: avg_viewers_per_stream, view_to_creator_rate, creator_activation_rate, streams_per_creator_per_day, time_window_hours, target_streams.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "67.1.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "67.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement a branching-process estimator to compute R0 = avg_viewers_per_stream × view_to_creator_rate × creator_activation_rate.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "67.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "67.3",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Compute required seed creators N0 for a target stream volume given R0 and streams_per_creator_per_day.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "67.3.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "67.4",
          "status": "completed",
          "notes": "Output-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Generate reports/viral_seed_estimate_<date>.json with N0, R0, and sensitivity ranges.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "67.4.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "67.5",
          "status": "pending",
          "notes": "",
          "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
          "subtasks": []
        },
        {
          "number": "67.6",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 67 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "68",
      "status": "completed",
      "notes": "Standalone budget optimizer; uses PJM cost. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement a launch budget optimizer that converts seed creator requirements into PJM and USD budgets for a one-day citywide launch.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "68.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create launch_budget_inputs.json with pjm_usd_rate, starter_reward_pjm, boost_reward_pjm_equivalent, and max_pjm_per_creator.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "68.1.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "68.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Compute total PJM + USD required for N0 seed creators and apply safety margin multipliers (1.2x, 1.5x).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "68.2.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "68.3",
          "status": "completed",
          "notes": "Output-only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Generate reports/launch_budget_estimate_<date>.json with low/base/high budget scenarios.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "68.3.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "68.4",
          "status": "pending",
          "notes": "",
          "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
          "subtasks": []
        },
        {
          "number": "68.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 68 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "69",
      "status": "completed",
      "notes": "Standalone trend detector; event-driven. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
      "description": "Implement a local trend detector that flags when a GeoCell crosses a stream-rate threshold and triggers map visibility boosts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "69.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create trend_thresholds.json with streams_per_hour, unique_creators_per_hour, and sustained_window_minutes.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "69.1.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "69.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement a detector that computes rolling stream rates and emits trend flags per GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "69.2.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "69.3",
          "status": "completed",
          "notes": "Event-driven. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Trigger a temporary boost and tag events with trend_id for post-analysis.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "69.3.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "69.4",
          "status": "pending",
          "notes": "",
          "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
          "subtasks": []
        },
        {
          "number": "69.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 69 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "70",
      "status": "completed",
      "notes": "Standalone seeding config; no external dependencies. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.\n\nПочему такой выбор: off‑campus+after‑school минимизирует барьеры согласований и юридические риски, оставляя эффект «рядом со школой»; private‑first даёт быстрые договорённости и символический престиж, который запускает эффект подражания; co‑ed фокус ускоряет «склейку» сетей и снижает фрагментацию аудитории. Публичные школы подключаем во 2‑й волне, когда есть доказанный эффект и кейсы для администраций.",
      "description": "Add a Bangkok pilot seeding map with GeoCell groups and launch waves to coordinate simultaneous activation.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений.\n\nРЕШЕНИЕ ДЛЯ ПИЛОТА (принято здесь и дальше используется как норматив): (1) запуск ТОЛЬКО после уроков и ВНЕ территории школы — off-campus geofence 300–600м вокруг кампуса; on-campus допускается только при отдельном письменном разрешении/партнёрстве; (2) тип школ для старта: private‑first (быстрее согласования и сильнее символический статус), public — волна 2 после подтверждения метрик; (3) аудитория: co‑ed по умолчанию (максимальная сеть и межклассные эффекты), а для single‑sex школ применяются те же механики, но с адаптированными квестами/креативами. Эти параметры должны быть закодированы в конфигах и проверяться в рантайме.",
      "subtasks": [
        {
          "number": "70.1",
          "status": "completed",
          "notes": "Config only. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Create bangkok_launch_waves.json with wave_id, geo_cell_ids, and target_seed_creators.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "70.1.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "70.2",
          "status": "completed",
          "notes": "Pure logic. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах. Этот пункт нужен для управляемого перехода к следующему этапу: он создаёт проверяемую опору, которая уменьшает неопределённость и даёт возможность повторить результат. Мы добиваемся этого через ясное определение входов, процедур обработки и критериев завершения. Ожидаемый итог — артефакт, который можно измерить, проверить и использовать в последующих шагах.",
          "description": "Implement a wave scheduler that activates starter-hack features by wave and logs activation timestamps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "70.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "70.3",
          "status": "pending",
          "notes": "",
          "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
          "subtasks": []
        },
        {
          "number": "70.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 70 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "71",
      "status": "completed",
      "notes": "Standalone experiment pack for Jasper hack strength. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement a Jasper-hack strength experiment comparing: (A) PJM+Glow, (B) Glow-only, (C) Glow+TrendBoost during launch hour.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "71.1",
          "status": "completed",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Extend experiments.json with jasper_strength variants and rollout weights.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "71.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "71.2",
          "status": "completed",
          "notes": "Analytics-only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Log activation, D1 retention, and k-factor per variant for launch-hour cohorts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "71.2.1",
              "status": "pending",
              "notes": "",
              "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "71.3",
          "status": "pending",
          "notes": "",
          "description": "Откалибровать модель на реальных метриках: заменить параметры на фактические значения, сделать сценарии low/base/high, проверить чувствительность, и сохранить выводы в отчёте.",
          "subtasks": []
        },
        {
          "number": "71.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 71 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Houseparty: волна хайпа не превратилась в устойчивый ритуал и продукт угас. Мы должны анализировать не только школы/волны, которые взлетели, но и те, что не дали эффекта. Нужна карта «failed waves»: какие окна, какие квесты, какой seed‑level. Сравниваем их с успешными волнами, корректируем расписание, плотность seed‑создателей, тип наград и ритуалов. Итог: стратегия запуска усиливается за счёт анализа провалов, и риск одноразового всплеска минимизируется. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "72",
      "status": "pending",
      "notes": "Turns Jasper loop into a real launch seeding pipeline. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.\n\nПочему такой выбор: off‑campus+after‑school минимизирует барьеры согласований и юридические риски, оставляя эффект «рядом со школой»; private‑first даёт быстрые договорённости и символический престиж, который запускает эффект подражания; co‑ed фокус ускоряет «склейку» сетей и снижает фрагментацию аудитории. Публичные школы подключаем во 2‑й волне, когда есть доказанный эффект и кейсы для администраций.",
      "description": "Implement a seed-creator acquisition playbook config and task generator for initial launch seeding.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений.\n\nРЕШЕНИЕ ДЛЯ ПИЛОТА (принято здесь и дальше используется как норматив): (1) запуск ТОЛЬКО после уроков и ВНЕ территории школы — off-campus geofence 300–600м вокруг кампуса; on-campus допускается только при отдельном письменном разрешении/партнёрстве; (2) тип школ для старта: private‑first (быстрее согласования и сильнее символический статус), public — волна 2 после подтверждения метрик; (3) аудитория: co‑ed по умолчанию (максимальная сеть и межклассные эффекты), а для single‑sex школ применяются те же механики, но с адаптированными квестами/креативами. Эти параметры должны быть закодированы в конфигах и проверяться в рантайме.",
      "subtasks": [
        {
          "number": "72.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create seed_creator_sources.json with schools/clubs/ambassadors and target counts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "72.2",
          "status": "pending",
          "notes": "Pure generation logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement generate_seed_tasks.py to output outreach task lists (JSON/CSV) by GeoCell.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "72.3",
          "status": "pending",
          "notes": "Schema only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Define seed_tracking_schema.json for attribution fields (source_id, status, first_stream_at).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "72.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 72 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "73",
      "status": "pending",
      "notes": "Safety layer required for school-scale launch. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement teen-safe content policy pack: policy config, linter, and moderation playbook report.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "73.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create content_policy.json with allowed/disallowed categories, severity, and actions.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "73.2",
          "status": "pending",
          "notes": "Pure logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement policy_linter.py to validate rule coverage and detect conflicting policies.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "73.3",
          "status": "pending",
          "notes": "Report output. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Generate moderation_playbook_<date>.json from policy with summary actions and escalation paths.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "73.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 73 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "74",
      "status": "pending",
      "notes": "Creates the external reason to go live layer. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement ritual campaign scheduler and shareable asset generator for recurring launch windows.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "74.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create ritual_campaigns.json with weekly themes, time windows, and GeoCells.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "74.2",
          "status": "pending",
          "notes": "Pure logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement schedule_ritual_campaigns.py to output active campaign windows per date.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "74.3",
          "status": "pending",
          "notes": "Asset generation only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement generate_campaign_assets.py to output share text/templates for campaigns.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "74.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 74 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "75",
      "status": "pending",
      "notes": "Encodes the Jasper myth-building layer. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement narrative loop toolkit to turn first streams into shareable local stories.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "75.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create narrative_templates.json for first-stream, local hero, and school rival narratives.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "75.2",
          "status": "pending",
          "notes": "Local rendering only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement generate_story_cards.py to produce SVG/PNG story cards with local stats.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "75.3",
          "status": "pending",
          "notes": "Mapping only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Add narrative_event_mapping.json to log share triggers for analytics attribution.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "75.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 75 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "76",
      "status": "pending",
      "notes": "Bridges internal trends to external visibility. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement external trend amplification pack for exporting trend payloads to external channels.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "76.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create external_trend_targets.json (hashtags, platform targets, export formats).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "76.2",
          "status": "pending",
          "notes": "Pure generation logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement export_trend_payloads.py to generate upload packages from trend flags.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "76.3",
          "status": "pending",
          "notes": "Schema only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create external_trend_log.json schema to manually log external pickups for analysis.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        }
      ]
    },
    {
      "number": "77",
      "status": "pending",
      "notes": "Defines the success criteria for Jasper ignition. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement launch KPI thresholds and blast-detection report for nuclear start validation.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "77.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create launch_kpi_thresholds.json with streams_per_30min, creators_per_hour, viewer_to_creator_rate, and trend_flags.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "77.2",
          "status": "pending",
          "notes": "Pure logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement detect_launch_blast.py to evaluate raw events against KPI thresholds.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "77.3",
          "status": "pending",
          "notes": "Report output. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Generate launch_blast_report_<date>.json with pass/fail and confidence score.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "77.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 77 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Houseparty: волна хайпа не превратилась в устойчивый ритуал и продукт угас. Мы должны анализировать не только школы/волны, которые взлетели, но и те, что не дали эффекта. Нужна карта «failed waves»: какие окна, какие квесты, какой seed‑level. Сравниваем их с успешными волнами, корректируем расписание, плотность seed‑создателей, тип наград и ритуалов. Итог: стратегия запуска усиливается за счёт анализа провалов, и риск одноразового всплеска минимизируется. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "78",
      "status": "pending",
      "notes": "Adds the external resource engine analogous to Klaus. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement partnership trigger layer for coordinated activations with local partners.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "78.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create partner_triggers.json with partner_id, reward pool, activation window, and target GeoCells.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "78.2",
          "status": "pending",
          "notes": "Pure logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement schedule_partner_triggers.py to activate partner windows and log events.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "78.3",
          "status": "pending",
          "notes": "Report output. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Generate partner_trigger_report_<date>.json summarizing active partners and spend caps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "78.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 78 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Secret/Whisper: сильный внешний стимул дал всплеск, но привычка не сформировалась, и аудитория ушла. Мы должны анализировать не только тех, кто участвует в ритуалах, но и тех, кто остановился после 1–2 действий. Нужна когортная аналитика «silent churn»: пользователи с 1 квестом, без повторения; сравнение их контекста (время, тип квеста, наличие награды) с успешными. На основе этого корректируются ритуалы, reward‑tapering и streak‑правила. Важно выявлять «невидимые» провалы (например, квесты слишком сложны или окно после школы не совпадает с расписанием). Итог: механизм превращения стимула в привычку должен учитываться не по средним метрикам, а по судьбе тех, кто «не вернулся». Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "79",
      "status": "pending",
      "notes": "Covers alternatives, strategic groups, buyer chain, complements, functional/emotional, trends. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement Six Paths Framework report: systematically reconstruct market boundaries.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "79.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create six_paths_inputs.json with competitor/alternative sets and assumptions.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "79.2",
          "status": "pending",
          "notes": "Pure generation logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement build_six_paths_report.py to generate a structured six-paths analysis JSON.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "79.3",
          "status": "pending",
          "notes": "Report output. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Generate reports/six_paths_<date>.json and a short summary JSON for dashboard.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "79.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 79 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — IRL: метрики были искусственно завышены, продукт потерял доверие и закрылся. В нашем плане нужно изучать не только измеряемые события, но и «невидимые» — пользователей без событий, расхождения GA4 и внутренних логов, пустые стримы. Создаётся отдельный отчёт survivorship‑bias по метрикам: какие события отсутствуют и как это влияет на выводы. Итог: метрики становятся достоверными, а решения принимаются на полной картине, а не только на «выживших» данных. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "80",
      "status": "pending",
      "notes": "Adds field-testing and validation loops per BOS. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
      "description": "Implement Visual Strategy Process artifacts (Awakening → Exploration → Strategy Fair → Communication).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "80.1",
          "status": "pending",
          "notes": "Config only. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Create visual_strategy_stages.json with stage checklists and required evidence fields.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "80.2",
          "status": "pending",
          "notes": "Pure logic. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Implement visual_strategy_tracker.py to record stage completion and evidence links.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "80.3",
          "status": "pending",
          "notes": "Report output. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации. Смысл этого пункта — создать прозрачный и воспроизводимый результат, который можно использовать дальше. Мы хотим получить ясную связь между входом, обработкой и выходом, чтобы любые следующие шаги были обоснованы. Способ: определить входные данные, выполнить трансформацию по правилам, зафиксировать результаты и проверки. Итогом должен быть отчёт/конфиг/скрипт, который можно проверить и повторить без ручной интерпретации.",
          "description": "Generate reports/visual_strategy_status_<date>.json and a printable summary HTML.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "80.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 80 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — IRL: метрики были искусственно завышены, продукт потерял доверие и закрылся. В нашем плане нужно изучать не только измеряемые события, но и «невидимые» — пользователей без событий, расхождения GA4 и внутренних логов, пустые стримы. Создаётся отдельный отчёт survivorship‑bias по метрикам: какие события отсутствуют и как это влияет на выводы. Итог: метрики становятся достоверными, а решения принимаются на полной картине, а не только на «выживших» данных. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "81",
      "status": "pending",
      "notes": "Maps features/releases into BOS portfolio health view. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Pioneer–Migrator–Settler (PMS) map for portfolio classification.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "81.1",
          "status": "pending",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create pms_map_inputs.json with feature list and classification criteria.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "81.2",
          "status": "pending",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement build_pms_map.py to classify features and compute portfolio balance.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "81.3",
          "status": "pending",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/pms_map_<date>.json and an SVG visual snapshot.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "81.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 81 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "82",
      "status": "pending",
      "notes": "Captures cognitive, resource, motivational, and political hurdles with actions. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Tipping Point Leadership checklist and constraint map.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "82.1",
          "status": "pending",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create tipping_point_hurdles.json with hurdle definitions and action templates.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "82.2",
          "status": "pending",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement build_tipping_point_plan.py to output a prioritized action list.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "82.3",
          "status": "pending",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/tipping_point_plan_<date>.json and summary for dashboard.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "82.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 82 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "83",
      "status": "pending",
      "notes": "Ensures BOS execution discipline. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Fair Process checklist (engagement, explanation, expectation clarity) for key initiatives.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "83.1",
          "status": "pending",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create fair_process_checklist.json with required fields and thresholds.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "83.2",
          "status": "pending",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement fair_process_audit.py to validate initiative records against checklist.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "83.3",
          "status": "pending",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/fair_process_audit_<date>.json with pass/fail and gaps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "83.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 83 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "84",
      "status": "pending",
      "notes": "Formalizes execution layer referenced in BOS. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Execution-into-Strategy integration report (link initiatives to metrics, owners, and timelines).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "84.1",
          "status": "pending",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create execution_integrations.json with initiative_id, owner, metrics, and timeline.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "84.2",
          "status": "pending",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement build_execution_map.py to output readiness score and dependency graph JSON.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "84.3",
          "status": "pending",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/execution_map_<date>.json and dashboard summary fields.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": []
        },
        {
          "number": "84.4",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 84 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — IRL: метрики были искусственно завышены, продукт потерял доверие и закрылся. В нашем плане нужно изучать не только измеряемые события, но и «невидимые» — пользователей без событий, расхождения GA4 и внутренних логов, пустые стримы. Создаётся отдельный отчёт survivorship‑bias по метрикам: какие события отсутствуют и как это влияет на выводы. Итог: метрики становятся достоверными, а решения принимаются на полной картине, а не только на «выживших» данных. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "85",
      "status": "completed",
      "notes": "BOS sustainability/renewal layer. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Sustainability & Renewal module to monitor imitation barriers and strategy drift.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "85.1",
          "status": "completed",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create imitation_barriers.json with factors (legal, brand, network effects, costs, data).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "85.1.1",
              "status": "pending",
              "notes": "",
              "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "85.2",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement assess_imitation_barriers.py to score barriers and output a risk index.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "85.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "85.3",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement strategy_drift_monitor.py to compare strategy_canvas snapshots and flag drift.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "85.3.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "85.4",
          "status": "completed",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/sustainability_<date>.json with barrier index and drift flags.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "85.4.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "85.5",
          "status": "pending",
          "notes": "",
          "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
          "subtasks": []
        },
        {
          "number": "85.6",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 85 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — IRL: метрики были искусственно завышены, продукт потерял доверие и закрылся. В нашем плане нужно изучать не только измеряемые события, но и «невидимые» — пользователей без событий, расхождения GA4 и внутренних логов, пустые стримы. Создаётся отдельный отчёт survivorship‑bias по метрикам: какие события отсутствуют и как это влияет на выводы. Итог: метрики становятся достоверными, а решения принимаются на полной картине, а не только на «выживших» данных. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "86",
      "status": "completed",
      "notes": "Explicit BOS risk assessment module. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement BOS Risk Matrix (search/planning/scale/business model/organizational/management risks).\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "86.1",
          "status": "completed",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create bos_risk_matrix.json with risk categories, scoring scale, and mitigation fields.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "86.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "86.2",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement assess_bos_risks.py to compute weighted risk scores.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "86.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "86.3",
          "status": "completed",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/bos_risk_<date>.json with scores and top mitigation gaps.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "86.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "86.4",
          "status": "pending",
          "notes": "",
          "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
          "subtasks": []
        },
        {
          "number": "86.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 86 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "87",
      "status": "completed",
      "notes": "Connects value innovation to cost structure. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Cost Driver Map linking ERRC factors to cost components and savings estimates.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "87.1",
          "status": "completed",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create cost_driver_map.json with ERRC factors, cost drivers, and expected impact ranges.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "87.1.1",
              "status": "pending",
              "notes": "",
              "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "87.2",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement compute_cost_driver_impact.py to estimate net cost delta.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "87.2.1",
              "status": "pending",
              "notes": "",
              "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "87.3",
          "status": "completed",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/cost_driver_impact_<date>.json with savings/risk summary.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "87.3.1",
              "status": "pending",
              "notes": "",
              "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "87.4",
          "status": "pending",
          "notes": "",
          "description": "Подтянуть финансовые данные: собрать реальные цены/затраты, пересчитать коридор и target cost, обновить модель с источниками, добавить комментарии по допущениям и зафиксировать итог в отчёте.",
          "subtasks": []
        },
        {
          "number": "87.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 87 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Zenly: высокий продуктовый эффект без устойчивой монетизации привёл к закрытию. Поэтому мы должны изучать не только успешные GeoCells, но и те, где PJM‑наградой «сожгли» бюджет без роста. Нужно формировать список убыточных ячейек, считать скрытые затраты (модерация, анти‑фрод, инфраструктура), и пересматривать лимиты/цены/пакеты. Далее — \"negative unit‑economics\" report: что именно отличает провальные ячейки (плохой seed, неверное окно, слабая локальная сеть). Итог: бюджетная стратегия должна быть построена с учётом «погибших» ячеек, чтобы не повторить ошибку Zenly. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "88",
      "status": "completed",
      "notes": "Adds real-world validation layer to Six Paths. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement External Validation Inputs pack for buyer chain and complementor field testing.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "88.1",
          "status": "completed",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create validation_inputs.json with interview targets, sample size, and hypothesis list.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "88.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "88.2",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement validate_field_tests.py to ingest results and compute confidence scores.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "88.2.1",
              "status": "pending",
              "notes": "",
              "description": "Довести контроль до рабочего уровня: добавить edge‑cases, убедиться, что правила покрывают все ключевые случаи, подготовить sample‑данные для проверки и включить этот контроль в рабочий пайплайн.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "88.3",
          "status": "completed",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/field_validation_<date>.json with evidence coverage and confidence.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "88.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "88.4",
          "status": "pending",
          "notes": "",
          "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
          "subtasks": []
        },
        {
          "number": "88.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 88 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — IRL: метрики были искусственно завышены, продукт потерял доверие и закрылся. В нашем плане нужно изучать не только измеряемые события, но и «невидимые» — пользователей без событий, расхождения GA4 и внутренних логов, пустые стримы. Создаётся отдельный отчёт survivorship‑bias по метрикам: какие события отсутствуют и как это влияет на выводы. Итог: метрики становятся достоверными, а решения принимаются на полной картине, а не только на «выживших» данных. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "89",
      "status": "completed",
      "notes": "Prevents red-ocean drift. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
      "description": "Implement Value Curve Drift Monitoring report to track focus/divergence over time.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
      "subtasks": [
        {
          "number": "89.1",
          "status": "completed",
          "notes": "Config only. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Create value_curve_drift_config.json with thresholds for focus/divergence decline.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "89.1.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "89.2",
          "status": "completed",
          "notes": "Pure logic. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Implement detect_value_curve_drift.py to compare historical strategy_canvas snapshots.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "89.2.1",
              "status": "pending",
              "notes": "",
              "description": "Сгенерировать итоговый отчёт на реальных данных, проверить формат/валидность, добавить в общий dashboard и зафиксировать ссылку на источник данных.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "89.3",
          "status": "completed",
          "notes": "Report output. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества. Назначение этого пункта — создать измеримую опору для стратегии и сделать действия проверяемыми. Мы хотим добиться прозрачного результата: чтобы было ясно, какие входы использованы, что именно сделано, и какой выход получен. Способ — описать входные требования, задать критерии готовности, и сформировать артефакт (конфиг/скрипт/отчёт), который можно повторить и масштабировать. Это снижает риски и облегчает контроль качества.",
          "description": "Generate reports/value_curve_drift_<date>.json with alerts.\n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. \n\nПодробности выполнения: 1) Подготовка: уточнить входы/выходы, ограничение по форматам, список полей и требуемые проверки. 2) Реализация: написать основные функции, добавить нормализацию, обработку ошибок, и логирование ключевых шагов. 3) Проверка: провести минимум 2 сценария — позитивный и негативный (ошибка/отказ). 4) Риски: описать, что будет при неполных данных и как себя вести при частичной доступности. 5) Готовность: критерий — предсказуемый результат, корректный отчёт и отсутствие побочных изменений. ",
          "subtasks": [
            {
              "number": "89.3.1",
              "status": "pending",
              "notes": "",
              "description": "Заполнить конфиг реальными значениями: собрать данные/источники, удалить плейсхолдеры, проверить корректность структуры и задокументировать допущения.",
              "subtasks": []
            }
          ]
        },
        {
          "number": "89.4",
          "status": "pending",
          "notes": "",
          "description": "Довести анализ до исследовательного уровня: заменить предположения на реальные источники (конкуренты, интервью, метрики), зафиксировать ссылки/доказательства, пересчитать оценки и сохранить версионированный результат для сравнения во времени.",
          "subtasks": []
        },
        {
          "number": "89.5",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 89 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "90",
      "status": "pending",
      "notes": "Этот блок формализует три ключевых решения пилота (off‑campus/after‑school, private‑first, co‑ed) и превращает их в проверяемые кодовые ограничения и отчётные срезы. Мы фиксируем «правила поля», чтобы команда не расходилась в трактовках, а аналитика могла разделить волны и доказать причинность. Результат: одинаковые правила во всех модулях (scheduler, gate, seeding, analytics), без ручных интерпретаций.",
      "description": "Добавить «операционную рамку пилота» в код: официально закрепить решения о том, где, как и с кем мы запускаем Jasper‑старт в Бангкоке. Рамка должна быть выражена в конфиге и валидироваться в рантайме. Решения: (1) запуск только после уроков и вне территории школы (off‑campus geofence 300–600м); (2) private‑first на первом этапе, public — волна 2; (3) co‑ed фокус по умолчанию, single‑sex — через адаптированные квесты и контент. Нужно добавить кодовые проверки, обновить конфиги, сегментацию аналитики и отчётов, а также проверить, что все ключевые модули используют один и тот же источник правды (config/bangkok_launch_waves.json и связанные конфиги).",
      "subtasks": [
        {
          "number": "90.1",
          "status": "pending",
          "notes": "Ввести поля activation_mode, geofence_radius_m, school_type_priority, audience_focus в конфигах, чтобы решения были машинно читаемы.",
          "description": "Обновить config/bangkok_launch_waves.json (и при необходимости другие launch‑конфиги) с полями: activation_mode='off_campus_after_school', geofence_radius_m (300–600), school_type_priority=['private','public'], audience_focus='coed', single_sex_overrides. Добавить проверку схемы в schedule_launch_waves.py и/или валидаторе конфигов, чтобы несоответствия ловились до запуска."
        },
        {
          "number": "90.2",
          "status": "pending",
          "notes": "Гарантировать, что запуск не уйдёт на территорию школ и не выйдет за окно after‑school.",
          "description": "Расширить schedule_launch_waves.py / after‑school scheduler: применять окно 15:30–18:00 Asia/Bangkok и проверять geofence_radius_m. Добавить флаг on_campus_allowed=false по умолчанию; если координаты внутри school polygon и разрешение не выдано, блокировать activation."
        },
        {
          "number": "90.3",
          "status": "pending",
          "notes": "Связать решения с механикой бонусов/квестов, чтобы Jasper‑механика запускалась только в корректных школах и окнах.",
          "description": "Обновить school pilot gate (task 54) так, чтобы он учитывал activation_mode, school_type_priority, audience_focus. Например, starter bonus + auto‑quest + boost включаются только при совпадении офф‑кампус/after‑school и private‑first волны; public разрешается после переключения волны в конфиге."
        },
        {
          "number": "90.4",
          "status": "pending",
          "notes": "Привязать ритуалы и квесты к after‑school и co‑ed фокусу без гендерной сегментации там, где это не нужно.",
          "description": "Обновить ritual calendar (task 36) и наборы квестов: по умолчанию co‑ed нейтральные формулировки, а для single‑sex школ — отдельные шаблоны (override). Убедиться, что расписание совпадает с after‑school окном."
        },
        {
          "number": "90.5",
          "status": "pending",
          "notes": "Без аналитической сегментации мы не докажем, что выбранная стратегия действительно работает лучше альтернатив.",
          "description": "Добавить в pipeline/дашборд измерения school_type, audience_focus, activation_mode и волны запуска. Обновить build_blue_ocean_dashboard.py и отчёты, чтобы можно было сравнивать private‑first vs public wave2, и co‑ed vs single‑sex."
        },
        {
          "number": "90.6",
          "status": "pending",
          "notes": "Обновить планы привлечения seed‑создателей и коммуникации так, чтобы они соответствовали выбранной рамке.",
          "description": "Обновить seed‑creator playbook (task 72): критерии отбора — private‑first, co‑ed, после уроков; добавить инструкции для single‑sex школ (адаптированные квесты). Обновить план волнового запуска с пометкой public‑wave‑2."
        },
        {
          "number": "90.7",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 90 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Meerkat/Periscope: live‑стриминг стал commodity и проиграл гигантам. Для нас это значит, что нужно изучать не только успешные локальные форматы, но и неудачные (квесты/темы, которые не зашли), чтобы понять, где мы теряем уникальность. Нужно выделить «failed local formats», сравнить их с успешными, и обновить карту ценности (value curve). Если локальная ценность падает, значит продукт дрейфует в сторону глобальной ленты — это «невидимый» провал, который видно только на неуспешных кейсах. Итог: регулярное выявление и устранение дрейфа, чтобы Pyjam оставался уникальным локальным продуктом. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    },
    {
      "number": "91",
      "status": "pending",
      "notes": "Сводим уязвимости аналогичных проектов в единый список и закладываем контр‑меры прямо в план. Цель — снизить вероятность провалов до минимально возможной, признавая, что 100% гарантий в реальном рынке не бывает. Для каждого исторического риска добавляем конкретный продуктовый/технический/процессный механизм, который можно проверить и измерить.",
      "description": "Добавить в план «Failure‑Pattern Countermeasures Pack»: набор обязательных механизмов, которые закрывают слабые места, выявленные в аналогичных проектах (Yik Yak, Secret, Whisper, Meerkat, Periscope, Houseparty, Zenly, IRL). Каждая контр‑мера должна быть привязана к конкретной рисковой точке (safety, toxic loops, habit/ritual, platform dependency, monetization, metrics integrity) и иметь измеримые критерии.",
      "subtasks": [
        {
          "number": "91.1",
          "status": "pending",
          "notes": "Пример негативного сценария — Yik Yak: локальная сеть без жёсткой safety‑архитектуры быстро превратилась в токсичную среду, школы вводили блокировки, пользователи уходили. Мы должны избежать роста через буллинг. Для этого внедряем Safety Gate, авто‑модерацию и гео‑ограничения, чтобы волна стримов не сломала репутацию. Результат: низкий toxicity_rate, быстрый stop‑stream и отсутствие школьных жалоб.",
          "description": "Задача 91.1 — реализовать полноформатный Safety Gate для Pyjam, который предотвращает повторение сценария Yik Yak: локальная сеть + подростки → токсичность → блокировки школами и спад. В рамках нашего проекта это означает не «общие слова про модерацию», а конкретный набор технических мер, встроенных в поток live‑стримов и квестов. Нужно определить в коде чёткий pipeline: (1) pre‑stream проверка условий (off‑campus geofence, окно after‑school, возраст/роль), (2) live‑moderation фильтры на текст/аудио/визуал, (3) быстрый флагинг инцидентов по сигналу пользователей, (4) автоматическое скрытие/понижение видимости при превышении порогов, (5) отчётность и аудит с сохранением сигналов для анализа. Это должно быть отражено в конфиге безопасности, иметь измеримые метрики (toxicity_rate, moderation_latency, incident_count), и выводиться в отчётах dashboard. Важно, чтобы все механизмы были именно «встроенными», а не ручными: автоматическое авто‑квантование (например, при высоком риске — только Glow без PJM или временный stop‑stream), и минимизация ущерба на уровне кода. Дополнительно нужно обеспечить процедуру «escalation» для инцидентов уровня критичности (подозрение на насилие/буллинг/самоповреждение), с конфигом SLA и автоматическим логированием. Это ядро для безопасного запуска волны стримов, так как без Safety Gate локальный рост превращается в токсичную вспышку и ломает репутацию на старте. Результат задачи — рабочие скрипты/модули (или хотя бы заглушки с интерфейсами), конфиги порогов и валидация, и отчёты, которые показывают, что gating реально работает и измеряется.",
          "subtasks": [
            {
              "number": "91.1.1",
              "status": "pending",
              "notes": "Yik Yak страдал от отсутствия реального модерационного контура. Здесь мы должны именно встроить realtime‑pipeline, чтобы не допустить токсичности во время волны. Делая это, мы получаем измеримый risk_score и автоматические действия; ожидаемый результат — остановка проблемных стримов до эскалации.",
              "description": "Реализовать модуль реального времени, который подключается к событию старта стрима/квеста и применяет последовательность фильтров: текстовые (chat/quest text), аудио (speech‑to‑text для обнаружения запрещённых фраз), визуальные (CV‑флаги на NSFW/насилие). Для нашего проекта это означает построение минимального каркаса: входы — stream_id, user_id, geocell, timestamp; выходы — risk_score, moderation_actions (allow, shadow, hide, stop). Важно, чтобы pipeline работал быстро, поэтому для MVP допустимы простые фильтры и stub‑модели с последующей заменой. Нужно добавить конфиг thresholds в config/* (например config/safety_thresholds.json) и обеспечить его загрузку. Отдельно требуется логирование каждого решения в safety_events.json (или таблицу), чтобы потом анализировать false‑positive/false‑negative. В описании функции должны быть проверки: если risk_score > критического порога → auto‑stop; если средний порог → reduce visibility + disable rewards; если низкий → allow. Для Pyjam этот модуль должен быть встроен в текущий pipeline квестов и стримов, чтобы при старте wave он уже «держал» риски. Дополнительно нужно обеспечить тестовый режим с симуляцией токсичного текста, чтобы QA мог проверить корректность. Результат — работающий модуль, чёткие метрики latency и доля остановленных стримов, а также отчёт для dashboard."
            },
            {
              "number": "91.1.2",
              "status": "pending",
              "notes": "Yik Yak показал, как быстро локальная среда уходит в травлю. Нужны явные анти‑буллинг правила и поведенческие сигналы, иначе волна будет разрушительной. Результат — снижение harassment_score и предотвращение повторных атак.",
              "description": "Создать формализованный ruleset анти‑буллинга в формате конфигурации, который применяется поверх pipeline. Он должен включать словари/паттерны (травля, оскорбления по признакам), поведенческие сигналы (повторяющиеся жалобы на пользователя, отрицательная реакция в чате, короткие burst‑атаки), и специальные «school‑mode» правила. Реализовать обработчик, который накапливает сигналы по пользователю и гео‑ячейке, формирует harassment_score, и делает авто‑действия: временное отключение чата, заморозка PJM‑наград, shadow‑ban в карте. Все изменения должны логироваться. Важно: правила должны быть «мягкими» на старте, но достаточно чувствительными, чтобы предотвратить эскалацию. В рамках планируемого кода — отдельный модуль (например scripts/anti_bullying_gate.py) и отчёт с топ‑срабатываниями. Нужно предусмотреть whitelisting для safe‑каналов и “cool‑down” логику. Этот шаг закрывает провал Yik Yak на уровне продуктовой культуры и безопасности и должен быть измерим по метрикам toxic_rate и harassment_score distribution."
            },
            {
              "number": "91.1.3",
              "status": "pending",
              "notes": "В Yik Yak школы блокировали приложение. Мы обязаны технически исключить on‑campus активность без разрешения. Результат — соблюдение политики off‑campus и снижение регуляторного давления.",
              "description": "Встроить техническое принуждение режима off‑campus: проверка координат стрима относительно полигона школы и заданного радиуса (300–600м). Если координата внутри запрещённой зоны и on‑campus не разрешён — стрим не запускается, либо допускается только в safe‑режиме без чата/вознаграждений. Для Pyjam нужно внедрить слой гео‑валидации в момент start_stream и в daily scheduler. Добавить структуру хранения school polygons (в конфиге или отдельном JSON), гео‑калькуляцию (haversine/polygon check), и лог событий blocked_by_geofence. Это необходимо, чтобы защититься от запрета школ, регуляторных рисков и чтобы сохранить возможность пилота. Требуются отчёты: % blocked streams, доля попыток on‑campus, тренды по гео‑ячейкам. Нужно предусмотреть fallback‑механику: если location missing — ограниченный режим без вознаграждений. Результат — enforceable политика, которая технически предотвращает нарушение условий запуска. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.1.4",
              "status": "pending",
              "notes": "Без эскалации инциденты превращаются в репутационные кризисы (урок Yik Yak/Secret). Здесь нужен SLA‑лог и реакция по уровням. Результат — время реакции контролируется, кризисы локализованы.",
              "description": "Создать систему эскалации инцидентов: определение уровней (P0/P1/P2), назначение реакции (auto‑stop, alert, review), и запись в отдельный incident log. Нужны минимальные SLA‑требования (например, P0 реагировать <5 мин) и фиксация времени: detected_at, action_taken_at, resolved_at. В коде это может быть отдельный файл reports/incident_log.json и функция, которую вызывают модерационные правила. Важно, чтобы этот лог был связан с dashboard (например, вывод в blue_ocean_dashboard.json) и позволял анализировать, насколько система выдерживает «бурные волны» стримов. Также нужно определить escalation path: кто получает уведомление, какой канал используется, какие критерии закрытия инцидента. Это предотвращает репутационные кризисы и является обязательным блоком для подростковой платформы. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            }
          ]
        },
        {
          "number": "91.2",
          "status": "pending",
          "notes": "Пример — Secret/Whisper: сильный внешний триггер не превратился в привычку, вовлечённость упала. Мы избегаем зависимости от PJM через tapering и перевод мотивации в статус/ритуалы. Конкретно: ритуальные окна, streaks, лестница статуса. Результат: D7 retention растёт без постоянных выплат.",
          "description": "Задача 91.2 — предотвратить провал Secret/Whisper, где внешний стимул не превратился в устойчивую привычку. Для Pyjam это критично: PJM и стартовые бонусы должны быть лишь «искра», а повторяемость должна удерживаться за счёт локального статуса, ритуалов и привычных окон. Нужно описать и реализовать механизм «reward tapering»: плановое снижение прямых наград при росте числа повторных стримов; переход к социальным и статусным стимулам (glow, топ района, титулы). Важно формализовать квест‑ритуалы (after‑school окно + weekly themes), внедрить streak‑механику с этичным freeze, и запустить лестницу создателя (creator identity). Это должно быть обвязано метриками retention (D1/D3/D7), ritual participation rate, ratio of reward‑driven vs organic streams. В коде нужны новые конфиги ритуалов, генераторы расписаний, измерения и отчёты. В результате задача гарантирует, что мы не зависим от постоянной раздачи денег и не повторяем слабость проектов, где рост держался только на «новизне». Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов.",
          "subtasks": [
            {
              "number": "91.2.1",
              "status": "pending",
              "notes": "Secret вырос на триггере, но не удержался, потому что стимул не перешёл в привычку. Здесь мы планируем tapering PJM и перенос мотивации в статус. Результат — рост органических стримов.",
              "description": "Создать формальный план снижения прямых PJM‑наград по мере взросления пользователя: например, первые 3 дня — PJM бонусы; дни 4–7 — комбинированный reward (PJM + статус); далее — преимущественно статус/видимость. В коде это означает ввод «reward phase» в профиле пользователя и в конфиге наград, чтобы engine мог выбирать тип награды в зависимости от стадии. Также нужно построить отчёт о доле reward‑driven vs organic streams (например, ratio_reward_streams) и вывести его в dashboard. Важно предусмотреть мягкий rollback: если retention падает, возвращаем часть PJM на время. Это ключевой механизм, чтобы не попасть в ловушку overjustification и обеспечить переход к внутренней мотивации. Должен быть описан формальный rule‑set с порогами, где видны параметры и способы их изменения без релиза (через конфиг). Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.2.2",
              "status": "pending",
              "notes": "Whisper/Secret не имели ритуалов, поэтому активность не повторялась. Мы вводим календарь ритуалов для повторяемости. Результат — стабильный ritual participation rate.",
              "description": "Интегрировать ежедневные и еженедельные ритуалы в core loop: after‑school окна + weekly theme (например, “Monday GRWM”, “Friday Squad”). Для проекта это означает создание календаря в конфиге и scheduler, который запускает автоматические challenge‑окна по GeoCell. Важно обеспечить, чтобы ритуалы были видимыми на карте (например, тематические Glow pins) и чтобы пользователи получали «мягкие» уведомления. Нужны наборы тем, привязанные к школьным расписаниям Бангкока. Метрика: % активных пользователей, участвующих в ритуале, и повторяемость участия по неделям. Это удержит вовлечённость без постоянного денежного стимула и превратит поведение в привычку. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.2.3",
              "status": "pending",
              "notes": "Внешняя мотивация быстро выгорает, если нет мягкого повторения. Этичные streaks дают привычку без давления. Результат — рост D7 retention без негативных сигналов.",
              "description": "Добавить streak‑механики для стримеров и зрителей с этичной «заморозкой». Это означает: streak считается при выполнении 60‑сек квеста в окне after‑school; допустим 1–2 “freeze” в неделю без потери streak. В коде нужен streak‑tracker, конфиг streak rules, и лог для аналитики. Важно запретить тёмные паттерны (например, навязчивые push‑уведомления), но позволить пользователю вернуть streak. Метрика: влияние streak на D7 retention, без роста негативных сигналов. Также надо добавить “streak‑health” индикатор, чтобы видеть, когда механика становится слишком давящей. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.2.4",
              "status": "pending",
              "notes": "Без идентичности пользователь уходит после новизны (Secret/Whisper). Лестница статуса делает стриминг частью роли. Результат — удержание и рост core creators.",
              "description": "Реализовать лестницу статуса: “Starter”, “Local Regular”, “School Top”, “Official School Streamer”. Каждый уровень открывает не денежные, а социальные преимущества (priority on map, custom badges, early access). Логика повышения — по последовательности участия в ритуалах и по выполнению квестов. В коде это означает хранение creator_level, правила продвижения, и визуальные элементы. Нужно добавить guardrails: уровень нельзя понижать из‑за кратких пауз, чтобы не стимулировать стресс. Это превращает стриминг в часть идентичности пользователя и закрывает слабость проектов, где мотивация была только внешней. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            }
          ]
        },
        {
          "number": "91.3",
          "status": "pending",
          "notes": "Пример — Meerkat/Periscope: live‑формат стал commodity и проиграл гигантам. Мы избегаем размывания уникальности, фиксируя map‑first discovery и локальные квесты. Результат: устойчивое отличие value‑curve и локальная вовлечённость > порога.",
          "description": "Задача 91.3 — исключить сценарий Meerkat/Periscope, когда live‑стриминг становится commodity и проигрывает гигантам. Для Pyjam нужно закрепить уникальное ядро: «локальный контекст + карта + интерактивные квесты + экономика». Это должно быть измеримо: мы фиксируем «value curve» и отличия от конкурентов (TikTok Live/Twitch) через метрики локальности, вовлечённости в квесты и доли “map‑first discovery”. Важно добавить мониторинг value‑curve drift — чтобы продукт не скатывался в общий формат глобального стрима. Также необходимо технически усилить local‑first механику: квест‑таксономия для гео‑контекста, локальные «обязательные» челленджи, и буст‑правила на карте. Без этого live‑ядро будет легко заменено крупной платформой. Результат: система доказуемо уникальна и защищена, а метрики позволяют ловить эрозию до того, как она разрушит стратегию. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов.",
          "subtasks": [
            {
              "number": "91.3.1",
              "status": "pending",
              "notes": "Meerkat/Periscope стали обычным live. Монитор дифференциации нужен, чтобы избежать соскальзывания в commodity. Результат — контроль уникальных метрик локальности.",
              "description": "Создать монитор, который сравнивает ключевые показатели Pyjam с отраслевыми бенчмарками и фиксирует «локальные преимущества»: % стримов, инициированных через карту; % квестов, связанных с локальной темой; средняя глубина взаимодействия (actions per stream). В коде это означает расширение build_blue_ocean_dashboard.py и добавление отчёта, который автоматически сигнализирует, если доля «локальных» взаимодействий падает ниже порога. Этот механизм защищает от размывания уникальности и делает позиционирование измеримым. Нужно указать thresholds в конфиге и логировать тренды по времени. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.3.2",
              "status": "pending",
              "notes": "Если квесты не локальны, продукт теряет отличия и повторяет Periscope. Локальная таксономия закрепляет гео‑ценность. Результат — доля локальных квестов выше порога.",
              "description": "Создать таксономию квестов, привязанных к локальному контексту (район, школа, микро‑события). Нужно разработать структуру категорий (school life, neighborhood, campus rituals) и реализовать генератор, который выбирает квесты на основании гео‑ячейки. Для Pyjam это кодовая база авто‑квестов + правила fallback, если локальных квестов нет. Метрика: доля локальных квестов > 60% во всех пилотных GeoCells. Это укрепляет уникальность и делает продукт не‑коммодити. Важно также добавлять локальные стикеры/темы, чтобы визуально отличать контент. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.3.3",
              "status": "pending",
              "notes": "Meerkat зависел от внешнего графа. Map‑first discovery создаёт собственный граф локальности. Результат — стабильный запуск через карту.",
              "description": "Внедрить алгоритм, который гарантирует, что новый пользователь проходит discovery через карту, а не через глобальную ленту. Это технически означает: первый экран — карта, рекомендация ближайших стримов, и обязательный локальный квест. Нужна проверка, что в on‑boarding отсутствует “global feed” без привязки к местности. Метрика: % onboard sessions, завершившихся локальным действием. Так мы избегаем превращения продукта в ещё одну глобальную ленту. Нужно добавить A/B вариант, чтобы доказать, что map‑first даёт лучшие метрики удержания. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.3.4",
              "status": "pending",
              "notes": "Без guardrails продукт может превратиться в глобальную ленту, как у конкурентов. Это нужно запретить на уровне конфигов. Результат — отсутствие drift в сторону global feed.",
              "description": "Добавить правила, запрещающие продуктовые решения, размывающие локальный фокус: например, нельзя добавлять «global trending» как главный экран без локальных фильтров. В коде это может быть конфиг‑флаг, валидатор релизов, и список запрещённых паттернов. Отчёт должен фиксировать, если доля глобального контента превышает порог. Это предотвращает стратегическую эрозию, которая уничтожила Meerkat/Periscope, и делает уникальность продукта устойчивой. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            }
          ]
        },
        {
          "number": "91.4",
          "status": "pending",
          "notes": "Пример — Houseparty: всплеск во время хайпа, но нет устойчивости после, поэтому продукт закрыли. Мы предотвращаем это через долгий календарь ритуалов, перезапуск волн и измерение post‑wave retention. Результат: активность удерживается спустя 4 недели.",
          "description": "Задача 91.4 — защититься от «всплеска без устойчивости», как у Houseparty: рост во время хайпа, затем резкий спад. Для Pyjam это значит, что после стартовой волны мы обязаны обеспечить структурированные «ритуальные» окна, регулярные кампании и автоматическое повторение локальных активностей. Нужно создать календарь кампаний на 6–12 недель вперёд, привязанный к школьному расписанию Бангкока, и обеспечить автоперезапуск волны через scheduler. Важно измерять “post‑wave retention”: через 2–4 недели после старта должны сохраняться повторные стримы. В коде нужно добавить механизм генерации кампаний, автоматических push‑триггеров, и отчёт о устойчивости. Результат — волна становится не разовым всплеском, а циклом, поддерживаемым ритуалами. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов.",
          "subtasks": [
            {
              "number": "91.4.1",
              "status": "pending",
              "notes": "Houseparty вспыхнул и погас, т.к. не было длительных кампаний. Нужен 12‑недельный календарь. Результат — прогнозируемая активность и повторяемость волн.",
              "description": "Создать конфиг кампаний на 12 недель, включая школьные ритуалы (after‑school), мини‑соревнования, тематические квесты. Нужны поля: период, тема, призы, гео‑фокус, “boost rules”. Этот конфиг должен использоваться scheduler‑ом для автоматического запуска волн. В отчёте фиксировать, какие кампании активированы и их результаты (streams per 1k users). Это предотвращает “разовый хайп” и превращает волну в повторяемый цикл. Нужны ясные критерии успеха по каждой кампании и автоматическое закрытие/перенос при слабом эффекте. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.4.2",
              "status": "pending",
              "notes": "После первой волны часто идёт спад. Автоперезапуск предотвращает затухание. Результат — стабилизация активности в GeoCell.",
              "description": "Добавить автоматический механизм перезапуска waves: если метрика активности падает ниже порога, scheduler инициирует “micro‑wave” с ограниченным бустом и квестами. В коде это означает: функция check_activity() + trigger_wave(). Важно избегать спама — лимит не чаще 1–2 раз в неделю на GeoCell. Метрика: доля GeoCells, где активность поддерживается. Это делает волну устойчивой и предотвращает спад. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.4.3",
              "status": "pending",
              "notes": "Houseparty потерял аудиторию после всплеска. Мы должны измерять post‑wave retention, иначе не увидим спад. Результат — чёткое понимание устойчивости.",
              "description": "Встроить отчёт, который измеряет retention через 14/28 дней после старта волны. Использовать cohorts (wave_start_date) и считать повторные стримы. Результат должен быть в dashboard и использоваться как критерий “wave success”. Это прямо закрывает провал Houseparty, где всплеск не закрепился. Должны быть отчёты для каждой GeoCell, чтобы отличать локальные успехи от провалов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            }
          ]
        },
        {
          "number": "91.5",
          "status": "pending",
          "notes": "Пример — Zenly: сильный продукт без устойчивой монетизации был закрыт стратегически. Мы избегаем этого через unit‑economics, пакеты спонсоров и safety‑контроль бюджета. Результат: positive margin per GeoCell и понятный путь к выручке.",
          "description": "Задача 91.5 — исключить судьбу Zenly: сильный продукт без устойчивой монетизации, который закрыли из‑за отсутствия бизнеса. Для Pyjam нужно закрепить экономическую модель: PJM‑лимиты, unit economics, локальные спонсорские пакеты, и прозрачный расчёт ARPU/LTV на уровне GeoCell. Это не значит «сразу продавать рекламу», но означает, что экономика должна быть измерима и доказуема. Нужны модули, которые считают стоимость наград, доходы от спонсоров/партнёров, и риски burn‑rate. Важно иметь в dashboard отчёт “positive unit‑economics per GeoCell”, чтобы масштабировать только те зоны, где экономика устойчиво положительна. Результат — защита от решения «продукт классный, но денег нет». Это фундамент выживания. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов.",
          "subtasks": [
            {
              "number": "91.5.1",
              "status": "pending",
              "notes": "Zenly был закрыт из‑за отсутствия понятной экономики. Нужен ledger расходов/доходов. Результат — прозрачный burn‑rate по GeoCell.",
              "description": "Создать модуль, который считает расход PJM по каждому GeoCell и сравнивает с потенциальным доходом (спонсорские пакеты, pay‑to‑boost, brand quests). В коде — ledger, который суммирует rewards per day, и отчёт, который показывает burn. Это важно для управления бюджетом. Метрика: cost_per_active_user и delta vs expected revenue. Нужно предусмотреть ежедневный export в reports/, чтобы команда могла принимать решения без ручного анализа. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.5.2",
              "status": "pending",
              "notes": "Zenly не монетизировал карту. Локальные пакеты создают путь к выручке. Результат — тестируемые revenue‑streams.",
              "description": "Разработать структуру локальных спонсорских пакетов: “районный спонсор”, “школьный челлендж”, “бренд‑квест”. Для плана нужны поля стоимости, длительности, KPI. Реализовать генератор пакетов в конфиге и отчёт для продаж. Это создаёт путь к монетизации и снижает риск Zenly. Важно прописать примеры пакетов и критерии эффективности, чтобы можно было тестировать и улучшать. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.5.3",
              "status": "pending",
              "notes": "Без атрибуции невозможно доказать экономику. Этот блок фиксирует ARPU/LTV. Результат — решение о масштабировании на данных.",
              "description": "Добавить в dashboard блок, показывающий ARPU/LTV по GeoCell, и сравнение с затратами PJM. Это означает расширение build_blue_ocean_dashboard.py и добавление метрик “net margin per cell”. Без этого мы не сможем доказать экономику перед масштабированием. Данные должны обновляться автоматически и сохраняться в reports/. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.5.4",
              "status": "pending",
              "notes": "Без предохранителей бюджет может сгореть в волне. Авто‑throttling защищает казну. Результат — управляемый расход PJM.",
              "description": "Встроить автоматические предохранители: если расходы в GeoCell превышают лимит, rewards переключаются на Glow‑only или уменьшаются. Это снижает риск превышения бюджета. Нужны правила throttling, отчёты превышений и предупреждения. Это обеспечивает устойчивость экономики и управляемость масштаба. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            }
          ]
        },
        {
          "number": "91.6",
          "status": "pending",
          "notes": "Пример — IRL: фейковые метрики разрушили доверие, проект закрыли. Мы исключаем это через anti‑bot, валидацию событий и сверку GA4/логов. Результат: расхождение метрик ниже порога и подтверждённые события.",
          "description": "Задача 91.6 — исключить сценарий IRL: фейковые метрики и потеря доверия инвесторов/рынка. Для Pyjam нужно встроить системный контур integrity: anti‑bot, device fingerprint, валидация событий, и сравнение GA4 с внутренними логами. Это означает: (1) фильтровать аномальные аккаунты (подозрительная скорость регистрации, однотипные события), (2) проверять, что события (quest_start/quest_complete) подтверждены фактами (длительность стрима, гео‑координаты), (3) регулярно сравнивать GA4 и внутреннюю аналитику по ключевым метрикам и логировать расхождения. Важно добавить автоматическое предупреждение, если расхождение > допустимого порога. Это защищает от «роста на бумаге», который убивает доверие. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов.",
          "subtasks": [
            {
              "number": "91.6.1",
              "status": "pending",
              "notes": "IRL рухнул из‑за фейковых пользователей. Anti‑bot правила — первая линия защиты. Результат — снижение фрода и достоверные метрики.",
              "description": "Создать набор правил для выявления ботов/ферм: аномально высокая скорость действий, повторяющиеся паттерны устройств, однотипные квесты без видео‑сигнала. Реализовать обработчик, который присваивает bot_score и исключает таких пользователей из отчётов. Важно: логировать все заблокированные аккаунты и пересчитывать метрики без них. Это базовая защита integrity. Нужно добавить конфиг порогов и возможность корректировки без релиза. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.6.2",
              "status": "pending",
              "notes": "IRL не проверял события. Валидация гарантирует, что quest_complete — реальное действие. Результат — меньше накрутки.",
              "description": "Построить pipeline, который подтверждает событие quest_complete по фактическим условиям: длительность стрима ≥ 45 сек, гео‑координаты валидны, наличие хотя бы одного viewer/бота‑квеста. Если условия не соблюдены — событие помечается invalid. Нужно хранить validation_status и учитывать его в аналитике. Это исключает «накрутку квестов». Также нужно добавить отчёт с долей invalid событий. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.6.3",
              "status": "pending",
              "notes": "Если GA4 и логи расходятся, доверие рушится (как в IRL). Сверка даёт контроль. Результат — расхождение в пределах допуска.",
              "description": "Разработать регулярный процесс сверки метрик GA4 и внутренних логов: totalUsers, streams, quest_complete. Разница > X% должна фиксироваться и выдавать alert. Для проекта это означает отдельный скрипт reconciliation и отчёт. Это обеспечивает прозрачность и предотвращает сценарий IRL. Важно зафиксировать допуски и расписание проверки. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.6.4",
              "status": "pending",
              "notes": "Без аудита аномалии проходят незаметно. Audit trail фиксирует спайки. Результат — прозрачность для инвесторов и команды.",
              "description": "Добавить системный audit trail для всех ключевых событий и anomaly‑alerts (например, sudden spikes). Это означает: хранить snapshots метрик, автоматически сравнивать с историей, и отправлять предупреждения в dashboard. Это создаёт доверие и позволяет доказать честность данных. Нужны правила, когда alert критичен, а когда просто info. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            }
          ]
        },
        {
          "number": "91.7",
          "status": "pending",
          "notes": "Пример — Yik Yak и другие подростковые продукты сталкивались с блокировками из‑за регуляторных рисков. Мы избегаем этого через age‑gating, parental consent и data minimization. Результат: compliance‑метрики в норме и отсутствие блокировок.",
          "description": "Задача 91.7 — обеспечить compliance для подростковой аудитории, чтобы избежать регуляторных блокировок и репутационных кризисов. Для Pyjam это включает age‑gating, parental controls, минимизацию данных и чёткую фиксацию согласий. Важно прописать конкретные поля в конфиге, где указаны возрастные лимиты и правила хранения. Также необходимо реализовать систему, которая ограничивает функции для младших возрастных групп (например, запрет на публичные стримы без подтверждения). В отчётах должны быть метрики по возрасту, наличию согласий и регуляторным флагам. Это не юридический документ, а техническая реализация правил, чтобы продукт не блокировался и мог масштабироваться в разных юрисдикциях. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов.",
          "subtasks": [
            {
              "number": "91.7.1",
              "status": "pending",
              "notes": "Подростковые продукты часто получают блокировки. Age‑gating снижает риск. Результат — корректный доступ по возрасту.",
              "description": "Реализовать возрастной gating: пользователь указывает возраст, и система применяет правила доступа. В коде нужно иметь age_group и правила для функционала: <13 — ограниченный режим, 13–15 — ограниченные функции, 16+ — полный доступ. Добавить проверку в начале стрима/квеста. Это снижает риск нарушений регуляций. Также нужно хранить историю изменений возраста и блокировать подозрительные изменения. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.7.2",
              "status": "pending",
              "notes": "Отсутствие согласий родителей повышает регуляторный риск. Логирование consent снижает опасность блокировок. Результат — подтверждённые статусы согласий.",
              "description": "Создать механизм согласия родителей для младших возрастов: логирование согласия, возможность ограничить функции, возможность отключить публичные стримы. В коде нужны поля consent_status и timestamp, а также функции для обновления/отзыва. Это важно для соответствия COPPA/локальным нормам. Нужно добавить отчёт с долей пользователей без согласия и действиями по ним. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.7.3",
              "status": "pending",
              "notes": "Лишние данные — риск штрафов и утечек. Минимизация снижает уязвимость. Результат — меньшее хранение чувствительных данных.",
              "description": "Ввести правила минимизации данных: хранить только необходимые поля, ограничить точность гео‑координат, срок хранения данных. Реализовать конфиг data_retention_policy и скрипт для очистки. Это снижает риск утечек и регуляторных штрафов. Важно прописать сроки хранения и обеспечить автоматическое удаление. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.7.4",
              "status": "pending",
              "notes": "Без мониторинга compliance легко пропустить нарушения. Дашборд даёт прозрачность. Результат — своевременное обнаружение рисков.",
              "description": "Добавить в dashboard блок compliance‑метрик: % пользователей с подтверждённым возрастом, % с согласиями, incidents of compliance. Это позволяет отслеживать соответствие требованиям в реальном времени. Нужны регулярные отчёты и метрики для аудиторов/партнёров. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            }
          ]
        },
        {
          "number": "91.8",
          "status": "pending",
          "notes": "Пример — Secret/Yik Yak: без чёткого плейбука инциденты приводили к репутационным кризисам. Мы избегаем этого через incident taxonomy, SLA и автоматический post‑mortem. Результат: быстрый response time и снижение ущерба.",
          "description": "Задача 91.8 — создать кризис‑план и playbook, чтобы проект не рушился от неожиданных инцидентов. Это урок Yik Yak/Secret/IRL: без управляемой реакции на инциденты продукт быстро теряет доверие. Для Pyjam нужно оформить “incident response” как кодовую структуру: список уровней инцидентов, действия, SLA, ответственные, каналы коммуникации, и автоматический post‑mortem. Это должно быть встроено в систему логирования: когда возникает критический инцидент, автоматически создаётся запись в incident log, фиксируются действия и сроки. Также важно прописать шаблоны коммуникаций (внутренние и внешние), чтобы команда быстро реагировала, не теряя времени на согласования. Результат — минимизация репутационного ущерба и способность сохранить устойчивость волны при кризисах. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов.",
          "subtasks": [
            {
              "number": "91.8.1",
              "status": "pending",
              "notes": "При кризисах без SLA происходят хаотичные действия, как у Secret. Инцидент‑таксономия задаёт порядок. Результат — контролируемое время реакции.",
              "description": "Создать классификацию инцидентов (P0/P1/P2), назначить целевые SLA по реакции и резолюции. В коде это означает: конфиг incident_levels.json, функции для создания инцидента с уровнем, расчёт SLA‑таймеров. Это даёт прозрачность и скорость реакции. Также нужно фиксировать ответственных и статус выполнения. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.8.2",
              "status": "pending",
              "notes": "Неподготовленные коммуникации приводят к репутационным ошибкам. Шаблоны ускоряют ответ. Результат — единообразные сообщения.",
              "description": "Подготовить шаблоны коммуникаций: внутренние (для команды) и внешние (для пользователей/партнёров). В коде это может быть JSON‑шаблон, который используется при генерации incident report. Это снижает время реакции и предотвращает хаотичные сообщения. Важно прописать правила, кто и когда использует шаблон. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.8.3",
              "status": "pending",
              "notes": "Если нет feature flags, опасные функции нельзя быстро отключить. Это повышает ущерб. Результат — быстрый rollback.",
              "description": "Встроить механизмы rollback и feature flags для отключения опасных функций (например, квесты или награды). В коде — config flags + проверка в runtime. Метрика: время отключения функции после инцидента. Это снижает ущерб и позволяет быстро стабилизировать волну. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            },
            {
              "number": "91.8.4",
              "status": "pending",
              "notes": "Без post‑mortem ошибки повторяются. Автоматический отчёт закрепляет обучение. Результат — снижение повторных инцидентов.",
              "description": "Создать шаблон и автоматический генератор post‑mortem отчёта, который собирает: описание инцидента, причины, принятые меры, рекомендации. Встроить в pipeline, чтобы каждый инцидент заканчивался обновлением правил. Это создаёт системное обучение. Важно хранить пост‑мортемы централизованно и использовать их в будущих релизах. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов. Дополнительная детализация для исполнения: нужно описать входы и выходы функций, зафиксировать формат событий (например, quest_start/quest_complete/stream_start), добавить минимальные проверки данных и обязательное логирование результатов в reports/ или logs/ с указанием даты, geo‑ячейки и идентификаторов. После реализации следует добавить небольшой скрипт‑валидатор (или unit‑тест) и включить метрику в dashboard, чтобы команда могла увидеть, что механизм работает на реальных данных и не зависит от ручных шагов."
            }
          ]
        },
        {
          "number": "91.9",
          "status": "pending",
          "notes": "Пример негативного сценария из аналогичных проектов учтён; задача добавлена для устранения survivorship‑bias.",
          "description": "Wald‑check (survivorship‑bias): для задачи 91 нужно дополнительно анализировать не только «выжившие» кейсы, но и «невозвраты» — те случаи, когда механизм не сработал, пользователи не вернулись, волна не разгорелась, или экономическая модель провалилась. Мы не имеем права строить выводы только по успешным данным, иначе повторим ошибки аналогичных проектов. В рамках Pyjam это означает создание отдельной выборки «failure‑cases», её сравнение с успешными и последующую корректировку порогов/механик/окна запуска. Пример негативного сценария — Yik Yak: локальная сеть без жёсткого safety‑контура быстро стала токсичной, школы блокировали, а продукт потерял доверие. Мы должны искать не только активные стримы, но и те, что были скрыты/остановлены, и случаи, когда пользователи ушли сразу после негативного опыта. Для этого нужно построить метрики «incident_after_first_stream», «shadowed_streams_ratio», «blocked_by_geofence_count», а также карту скрытых токсичных зон по GeoCell. Затем сравнить эти зоны с «чистыми», выявить различия в квестах/окнах/соц‑контексте и скорректировать правила: ужесточить фильтры, ограничить награды, изменить окно запуска или вводить manual review. Итог: safety‑механизмы должны предотвращать именно те случаи, которые не попали в основную аналитику, и снижать риск репутационного провала. Результат подзадачи: сформированный список failure‑cases, отчёт сравнения, корректировка порогов/механик и фиксация обновлённых правил. Это должно стать обязательной частью еженедельного анализа, чтобы план не повторял провалы аналогичных проектов."
        }
      ]
    }
  ]
}